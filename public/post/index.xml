<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Behaviour | Environment | Data</title>
    <link>https://bedatablog.netlify.com/post/</link>
      <atom:link href="https://bedatablog.netlify.com/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Urs Kalbitzer 2023</copyright><lastBuildDate>Sat, 22 Jul 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://bedatablog.netlify.com/img/icon-192.png</url>
      <title>Posts</title>
      <link>https://bedatablog.netlify.com/post/</link>
    </image>
    
    <item>
      <title>Foraging Simulation following Geometric Framework Models  - Part 1</title>
      <link>https://bedatablog.netlify.com/post/food-simulation-i/</link>
      <pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://bedatablog.netlify.com/post/food-simulation-i/</guid>
      <description>
&lt;script src=&#34;https://bedatablog.netlify.com/post/food-simulation-i/index_files/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://bedatablog.netlify.com/post/food-simulation-i/index_files/viz/viz.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://bedatablog.netlify.com/post/food-simulation-i/index_files/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://bedatablog.netlify.com/post/food-simulation-i/index_files/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;

&lt;/div&gt;

&lt;p&gt;Conception, Idea, and Writing: Patrick Lauer and Urs Kalbitzer. Realization and Programming: Patrick Lauer.&lt;/p&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Animals forage to meet their nutritional needs while avoiding potentially harmful components, such as toxins. &lt;strong&gt;Geometric Framework Models&lt;/strong&gt;, which have gained popularity in recent years, provide a framework that takes into account that there is rarely one single resource that satisfies an animal’s nutritional requirements and animals have to balance the consumption of different food resources with different nutritional compositions &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-lambert2015&#34;&gt;Lambert &amp;amp; Rothman, 2015&lt;/a&gt;; &lt;a href=&#34;#ref-simpson2011&#34;&gt;Simpson &amp;amp; Raubenheimer, 2011&lt;/a&gt;)&lt;/span&gt;. Thus, following Geometric Framework Models, the selection of food resources is not just based on general preferences for specific food items and their availability in the environment. Rather it depends on the animal’s nutritional goals, the composition (i.e. nutrients, harmful components) as well as the availability of food resources, and the animal’s current nutritional state (i.e. which nutrients have recently been consumed), see Figure &lt;a href=&#34;#fig:diag&#34;&gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Empirical studies on animal foraging behavior often focus on estimating preferences for different food items, which is usually done by calculating &lt;strong&gt;electivity indices&lt;/strong&gt; &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-manly2007&#34;&gt;Manly et al., 2007&lt;/a&gt;)&lt;/span&gt;. Such indices have been developed with the assumption that animals consume different food items proportionally to their preferences for, and the availability of, the different items in the environment. This, however, hardly captures the complex decision-making processes involved in foraging.&lt;/p&gt;
&lt;p&gt;Assuming that Geometric Framework Models better reflect animal foraging decisions than just preference models, the applicability of such electivity indices is unclear. Therefore, &lt;strong&gt;we here simulate animals foraging according to such Geometric Framework Models to explore nutrient acquisition in different scenarios&lt;/strong&gt; &lt;strong&gt;(Part 1), and then calculate electivity indices based on the observed consumption of different food items to compare these indices with what we know about the foraging behavior of our simulated animals (Part 2).&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:diag&#34;&gt;&lt;/span&gt;
&lt;div class=&#34;grViz html-widget html-fill-item-overflow-hidden html-fill-item&#34; id=&#34;htmlwidget-1&#34; style=&#34;width:672px;height:480px;&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;diagram&#34;:&#34;digraph flowchart {\n  node [shape=box, style = filled];\n\n    7 [label = \&#34;Electivity Scores\&#34;, fillcolor = PaleGreen]\n\n  node[fillcolor = LightCoral]\n    2 [label = \&#34;Availability of Food Resources in the Environment\&#34;];\n    3 [label = \&#34;Composition of Food Resources\&#34;];\n    4 [label = \&#34;Overall Nutritional Goals\&#34;];\n\n  node[fillcolor = lightblue]\n    1 [label = \&#34;Diet\&#34;];\n    6 [label = \&#34;Subjective Availability of Food Resources\&#34;];\n    5 [label = \&#34;Current Nutritional State\&#34;];\n\n    2 -&gt; 6[arrowhead = \&#34;none\&#34;];\n    6 -&gt; 1;\n    3 -&gt; 1;\n    4 -&gt; 1;\n    5 -&gt; 1;\n    1 -&gt; 5;\n    1 -&gt; 7;\n    2 -&gt; 7;\n\nsubgraph {\n rank = same; 2; 3; 4;}}&#34;,&#34;config&#34;:{&#34;engine&#34;:&#34;dot&#34;,&#34;options&#34;:null}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Diagram illustrating the assumptions simulated for Geometric Framework Models. The red coloured boxes highlight set parameters in the simulation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;general-concept-of-the-simulation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;General concept of the simulation&lt;/h2&gt;
&lt;p&gt;The basic idea is that the (simulated) animals have an &lt;strong&gt;optimal, or target, ratio&lt;/strong&gt; of different nutrients, for example a ratio of proteins (P) to carbohydrates (C) of &lt;strong&gt;1P:1C&lt;/strong&gt;. There are &lt;strong&gt;different food items&lt;/strong&gt; in the environment, and these items vary with regard to their &lt;strong&gt;nutritional content&lt;/strong&gt;, for example item A has 3 units protein and 1 unit carbohydrates (= 3P:1C), whereas another item B has 1 unit proteins and 3 units carbohydrates (= 1P:3C). Thus, &lt;strong&gt;neither item will allow an animal to stay close to their target ratio of 1P:1C&lt;/strong&gt; and they have to feed from both items. In other words, after each feeding event, the ratio of consumed nutrients will deviate from the target ratio in one or another direction. This affects which food item should be eaten next. However, in our simulation (and in nature), different items can vary with regard to their &lt;strong&gt;availability&lt;/strong&gt;, it is thereby ‘easier’ for animals to consume more abundant items. This means that which item is selected in each feeding event depends on &lt;em&gt;(i)&lt;/em&gt; how much the ratio of consumed nutrients would deviate from the target ratio after eating that item and &lt;em&gt;(ii)&lt;/em&gt; the availability of different food items.&lt;/p&gt;
&lt;p&gt;This simulation is done using the function &lt;code&gt;geometric_framework()&lt;/code&gt;, for which the code is provided below. For each individual, the simulation runs through &lt;em&gt;n&lt;/em&gt; feeding events. For each feeding event, the function calculates the cumulative units of each nutrient that would be consumed if a particular food item was eaten, and how much the new nutrient ratio would deviate from the target ratio. Based on this deviation and the availability of the item, the function calculates the relative probability of consuming each item, which is then used to determine which item is actually consumed (more details are provided below). The cumulative nutrient units consumed are updated for that individual after each feeding event.&lt;/p&gt;
&lt;p&gt;This simulation is done for a given number of individuals, which currently all have the same nutritional target. Furthermore, all individuals can feed on the same food items, each item with a defined content of different nutrients. However, we simulate inter-individual variability in the availability of food items (subjective food availability) to mimic natural variation between individuals due to differences in feeding position, cognitive capacities (i.e., skills to find and utilize specific items) and other factors. This variability is realized using a beta-distribution. The function can be used to simulate different kinds of scenarios to explore how animals would move through their nutritional landscapes.&lt;/p&gt;
&lt;p&gt;Currently, some options are still missing but we will implement them at a later stage:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Assigning potentially harmful components that an animal wants to avoid.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Simulating the expenditure of resources while foraging.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Defining more than two different nutrients per item.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Adding a “consumption effect”, thus a decrease in availability if an item was consumed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Most of these options should be straightforward to implement the way we set up the function.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calculating-the-deviation-from-optimal-nutrient-ratio-and-probability-of-selecting-food-items&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Calculating the deviation from optimal nutrient ratio and probability of selecting food items&lt;/h2&gt;
&lt;p&gt;As described above, for each potentially consumed food item, the deviation from the optimal ratio of consumed nutrients has to be calculated. This however, comes with one challenge that is illustrated in Figure &lt;a href=&#34;#fig:fig-dev-optimal&#34;&gt;2&lt;/a&gt;. Consider a simple example with only two nutrients, a and b, where an animal has an optimal ratio of 1a:1b for these nutrients. If the animal has the option between an item with 3a:1b and another item with 1a:3b, the deviations resulting from consuming each item should be symmetrical, with 3 times more of nutrient a in one case and 3 times more of nutrient b in the other. However, differences between the slope of the original/optimal line (s0 = 1) and the slopes of the two new lines (s1 = 3 for Item 1 and s2 = 1/3 for Item 2) would be 3 - 1 = 2 and 1/3 - 1 = -2/3, respectively.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:fig-dev-optimal&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;staticfig-dev-optimal-1.png&#34; alt=&#34;Potential deviation from optimal nutrient ratio when consuming different food items.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Potential deviation from optimal nutrient ratio when consuming different food items.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;To overcome the challenge explained above, we can use the magnitudes of differences between the optimal slope &lt;span class=&#34;math inline&#34;&gt;\(s\\{optimal} =\frac{optimal{Nutrient1}}{optimal{Nutrient2}}\)&lt;/span&gt; and the potential new slope that arises when consuming a particular item &lt;span class=&#34;math inline&#34;&gt;\(s\\{new} =\frac{potential{Nutrient1}}{potential{Nutrient2}}\)&lt;/span&gt; . This can be done by using the log of the ratio between the new slope and the original slopes &lt;span class=&#34;math inline&#34;&gt;\(log(\frac{s\\{new}}{s\\{optimal}})\)&lt;/span&gt; . Using this approach, the deviations become symmetrical and can be compared, as illustrated in Figure &lt;a href=&#34;#fig:log-for-dev&#34;&gt;3&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;snew &amp;lt;- c(1/6:1, 2:6)
s_opt_1 &amp;lt;- 1
s_opt_2 &amp;lt;- 0.5
plot(x = log(snew), y = log(snew/s_opt_1),
     main = &amp;quot;For optimal ratio of 1a:1b&amp;quot;,
     xaxt = &amp;quot;n&amp;quot;,
     xlab = &amp;quot;New ratio&amp;quot;,
     ylab = &amp;quot;Deviation: log(s_new/s_optimal)&amp;quot;)
axis(side = 1, at = log(snew), labels = round(snew, 2),
     las = 2)
# Line for deviations
lines(x = log(c(0.5, 1, 1, 1, 2)),
            y = log(c(0.5, 0.5, 1, 2, 2)/s_opt_1),
            lty = 1, col = &amp;quot;red&amp;quot;)
# Optimal line
lines(x = c(log(1), log(1)), y = c(log(min(snew)/1), log(max(snew)/1)),
      lty = 2, col = &amp;quot;grey20&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:log-for-dev&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;staticlog-for-dev-1.png&#34; alt=&#34;Potential deviation from optimal nutrient ratio when consuming different food items illustrated as magnitude of slope differences.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: Potential deviation from optimal nutrient ratio when consuming different food items illustrated as magnitude of slope differences.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The x-axis indicates the new ratio after consuming a food item with the vertical dashed line showing the optimal ratio. The y-axis illustrates the deviation calculated as described above. By using this approach the absolute value of the deviation between 1 (the optimal ratio) and the new ratio 1:2 (0.5) is the same as between the optimal ratio of 1 and the new ratio of 2:1 (2).&lt;/p&gt;
&lt;p&gt;To put this into a formula, the deviation from the optimal ratio after consuming item &lt;em&gt;k&lt;/em&gt; by individual &lt;em&gt;j&lt;/em&gt; in feeding event &lt;em&gt;i&lt;/em&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
deviation_{i, j, k} = log(\frac{slope_{optimal}}{slope_{i, j, k}})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here, &lt;span class=&#34;math inline&#34;&gt;\(slope_{i,j, k}\)&lt;/span&gt; is the slope of the line between 0 and consumed units of nutrients after the feeding event &lt;em&gt;i&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;It is important to note that the change in this deviation after each new food item becomes less severe if an individual has already consumed many items. That’s because we are using the cumulative amount of consumed nutrients which decreases the &lt;em&gt;relative&lt;/em&gt; importance of each new item for the ratio of already consumed nutrients. In other words, an individual becomes less picky if it has already consumed many nutrients because each new item would only have little impact on the ratio of consumed nutrients.&lt;/p&gt;
&lt;p&gt;We then define the probability of choosing item &lt;em&gt;k&lt;/em&gt; by individual &lt;em&gt;j&lt;/em&gt; in feeding event &lt;em&gt;i&lt;/em&gt; (&lt;span class=&#34;math inline&#34;&gt;\(P_{i,j,k}\)&lt;/span&gt;) as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
P_{i, j, k} = (1 - (\frac{deviation_{i, j, k}}{threshold})^2) * availabilty_{i,k}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Here, &lt;span class=&#34;math inline&#34;&gt;\(threshold\)&lt;/span&gt; is the maximum tolerable deviation of the nutritional ratio compared to the optimal ratio before an individual stops feeding on a particular item. And &lt;span class=&#34;math inline&#34;&gt;\(availability_{i,k}\)&lt;/span&gt; is the availability of food item &lt;em&gt;i&lt;/em&gt; for individual &lt;em&gt;k&lt;/em&gt;. Note that these are relative probabilities (or weights) calculated for each food item (per individual and feeding event) and they don’t sum up to 1 for each potential feeding event. In other words, if the deviation from the optimal value increases, the probability of selecting this specific food item decreases. The multiplication term for food availability &lt;span class=&#34;math inline&#34;&gt;\((1 - (\frac{deviation_{i, j, k}}{threshold})^2)\)&lt;/span&gt; is illustrated in Figure &lt;a href=&#34;#fig:fig-threshold&#34;&gt;4&lt;/a&gt; with different threshold values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow = c(1,2))
curve((1 - (x/0.5)^2), from = -0.5, to = 0.5,
      main = &amp;quot;Threshold = 0.5&amp;quot;,
      xlab = &amp;quot;Deviation from optimal nutrient value&amp;quot;,
      ylab = &amp;quot;Multiplicator for food availability&amp;quot;)
curve((1 - (x/1)^2), from = -1, to = 1,
      main = &amp;quot;Threshold = 1&amp;quot;,
      xlab = &amp;quot;Deviation from optimal nutrient value&amp;quot;,
      ylab = &amp;quot;Multiplicator for food availability&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:fig-threshold&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;staticfig-threshold-1.png&#34; alt=&#34;Weight of multiplication term for food availability with different threshold values.&#34; width=&#34;864&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 4: Weight of multiplication term for food availability with different threshold values.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;define-the-function&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Define the function&lt;/h2&gt;
&lt;p&gt;The function below to simulate animals following Geometric Framework Models follows the logic explained above.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;geometric_framework &amp;lt;- function(items_nutrients = list(c(3,1), c(1,3), c(1,1)),
                                items_availability = c(0.8, 0.8, 0.8),
                                optimal_ratio = c(2,1),
                                threshold_deviation = 1,
                                n_feeding_events = 100,
                                n_individuals = 10,
                                initial_nutrients = c(0,0),
                                return_class = c(&amp;quot;list&amp;quot;, &amp;quot;df&amp;quot;)) {
  
  # If no return class is specified, use first type in vector (here a list)  
  return_class &amp;lt;- match.arg(return_class)
  
  ## Do some checks
  if (length(items_nutrients) != length(items_availability))
    stop(&amp;quot;Length of items_nutrients and items_availability differ.
         Provide nutrients and availability for all items included.&amp;quot;)
  if(any(lapply(items_nutrients, length) != 2)) stop(&amp;quot;Currently, only two types of nutrients per item allowed.&amp;quot;)
  if(any(lapply(items_availability, length) != 1)) stop(&amp;quot;Provide one availability value per item.&amp;quot;)
  
  
  ## Define Beta density function parameterized with &amp;quot;prob&amp;quot; and &amp;quot;theta&amp;quot; for adding
  # &amp;quot;noise&amp;quot; to food availability. Taken from
  # https://rdrr.io/github/rmcelreath/rethinking/src/R/distributions.r
  rbeta2 &amp;lt;- function( n , prob , theta ) {
    a &amp;lt;- prob * theta
    b &amp;lt;- (1-prob) * theta
    rbeta( n , shape1 = a , shape2 = b)
  }
  
  ## Initialize Variables and Objects
  
  # Prior to the first feeding event, animals current nutrients are the set to initial_nutrients
  current_nutrients_per_individual &amp;lt;- rep(list(initial_nutrients), n_individuals)
  
  # Set up helper variables and vector for probabilities to choose each item
  n_nutrients &amp;lt;- length(items_nutrients[[1]])
  n_items &amp;lt;- length(items_nutrients)
  probability_weight_choosing_item &amp;lt;- rep(NA, n_items)
  
  # Set up matrix for items consumed with feeding events as rows and individuals as columns
  items_consumed &amp;lt;- matrix(NA, nrow = n_feeding_events, ncol = n_individuals)
  
  # Set up array for consumed nutrients with feeding events as rows (first
  # index), individuals as columns (second index), and the different nutrients in
  # the third dimension (third index)
  nutrients_consumed &amp;lt;- array(NA, dim = c(n_feeding_events, n_individuals, n_nutrients))
  
  dimnames(nutrients_consumed) &amp;lt;-  list( 1:n_feeding_events,
                                         1:n_individuals,
                                         1:n_nutrients)
  
  # Save parameters as attributes
  attr(nutrients_consumed, &amp;quot;items_nutrients&amp;quot;) &amp;lt;- items_nutrients
  attr(nutrients_consumed, &amp;quot;items_availability&amp;quot;) &amp;lt;- items_availability
  attr(nutrients_consumed, &amp;quot;optimal_ratio&amp;quot;) &amp;lt;- optimal_ratio
  
  
  # For each item, add inter-individual variability in food availability using the above defined function rbeta2
  availability_per_individual &amp;lt;- t(sapply(items_availability, function(x)
    rbeta2(n = n_individuals, prob = x, theta = 500)))
  
  ## Apply Geometric Framework assumptions to select which food item to include in diet
  
  # Go though all feeding events...
  for (event_i in 1:n_feeding_events) { 
    
    #... and for each feeding event, through all individuals...
    for (individual_j in 1:n_individuals) { 
      
       # ... and for each individual through all items.
      for (item_k in 1:n_items) {
        
  # First, determine how nutrients would look like if item_k is added to current nutrients
    potential_nutrients &amp;lt;- current_nutrients_per_individual[[individual_j]] + items_nutrients[[item_k]]
        
  # Transform optimal ratio and potential ratio from vector to numeric value
    optimal_ratio_numeric &amp;lt;- optimal_ratio[1] / optimal_ratio[2]
    potential_nutrient_ratio_numeric &amp;lt;- potential_nutrients[1] / potential_nutrients[2]

  
  # Calculate the deviation from the optimal nutrient acquisition if item_k was consumed 
    deviation_from_optimal_nutrients &amp;lt;- log(optimal_ratio_numeric/ potential_nutrient_ratio_numeric)
        
  # Set probability to select item_k according to how much the nutrients
  # deviate from the optimal amount.  Note that the probabilities
  # for all different items don&amp;#39;t have to sum up to 1 to be
  # used in `sample()`, they are rather considered as relative weights.
        
  # If deviation &amp;gt; threshold, set value to 0
    if(abs(deviation_from_optimal_nutrients) &amp;gt; threshold_deviation){
          probability_weight_choosing_item[item_k] &amp;lt;- 0
    } else {
     # Explanation in text, but in short: if deviation is 0, just use food
     # availability as probability. With increasing deviation, put a larger
     # penalty on item and decrease probability accordingly.The severity of 
     # the penalty is dependent on the threshold of maximum &amp;quot;allowed&amp;quot; deviation 
      probability_weight_choosing_item[item_k] &amp;lt;- (1 - (deviation_from_optimal_nutrients/threshold_deviation)^2) *
      availability_per_individual[[item_k, individual_j]]
     }
        
      }
      
  # Based on probability/weight, select one of the food items 
      item_selected &amp;lt;- sample(x = 1:n_items, size = 1, prob = probability_weight_choosing_item)
  
  # Add the nutrients of the selected item to current nutrients
      current_nutrients_per_individual[[individual_j]] &amp;lt;- current_nutrients_per_individual[[individual_j]] +
        items_nutrients[[item_selected]]
      
  # Assign new current nutrient values to cells in array
      nutrients_consumed[event_i, individual_j, ] &amp;lt;- current_nutrients_per_individual[[individual_j]]
      
  # Store information about which item was included in the diet in a matrix   
      items_consumed[event_i, individual_j] &amp;lt;- item_selected
      
    }
  }
  
  # Finally, return object according to return_class
  if(return_class == &amp;quot;list&amp;quot;){
    
    geom_frame_list &amp;lt;- list(nutrients_consumed, items_consumed)
    names(geom_frame_list) &amp;lt;- c(&amp;quot;Consumed Nutrient Units&amp;quot;, &amp;quot;Items in Diet&amp;quot;)
    
    return(geom_frame_list)
    
  }else if(return_class == &amp;quot;df&amp;quot;){
    
    nutrients_consumed_df &amp;lt;- as.data.frame(as.table(nutrients_consumed[,,1]))
    names(nutrients_consumed_df) &amp;lt;- c(&amp;quot;Feeding_event&amp;quot;, &amp;quot;Individual&amp;quot;, &amp;quot;Nutrient1&amp;quot;)
    nutrients_consumed_df$Nutrient2 &amp;lt;- as.vector(nutrients_consumed[,,2])
    nutrients_consumed_df$Item_in_diet &amp;lt;- as.data.frame(as.table(items_consumed))[[3]]
    
    return(nutrients_consumed_df)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;running-the-simulation-for-different-scenarios&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Running the simulation for different scenarios&lt;/h2&gt;
&lt;p&gt;We test our function in a simple example. In a group of 10 individuals, each individual has the nutritional target of obtaining protein and carbohydrates in a 2P : 1C ratio. The three available food items in the environment have the following nutrient composition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;item 1’s nutritional composition is 3P:1C&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;item 2’s nutritional composition is 1P:3C&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;item 3’s nutritional composition is 1P:1C&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To explore how the nutritional acquisition happens depending on limited resources, the individuals are “provided” with these three items in varying levels of availability in 3 different scenarios:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Scenario: All items are equally scarce.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scenario: Only item 1 (3P:1C) is highly abundant, the remaining items are scarce.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scenario: Only item 2 (1P:3C) is highly abundant, the remaining items are scarce.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;preparation-to-run-the-simulation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Preparation to run the simulation&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## setup for function
items_nutrients &amp;lt;- list(c(3,1), c(1,3), c(1,1))
optimal_ratio &amp;lt;- c(2,1)
threshold_deviation &amp;lt;- 1
n_feeding_events &amp;lt;- 150
n_individuals &amp;lt;- 10
initial_nutrients &amp;lt;-  c(0,0)
return_class &amp;lt;- &amp;quot;df&amp;quot;

## setup for plotting
library(ggplot2)
theme_set(theme_minimal())
optimal_carbohydrates &amp;lt;- 1:200
optimal_protein &amp;lt;- 2* optimal_carbohydrates &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;scenario-1-all-items-equally-scarce&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Scenario 1: All items equally scarce&lt;/h3&gt;
&lt;p&gt;In this scenario we set each item to the same, scarce (0.2) availability value.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;items_availability_scenario1 &amp;lt;- c(0.2, 0.2, 0.2)

gf_df1 &amp;lt;- geometric_framework(items_nutrients = items_nutrients,
                              items_availability = items_availability_scenario1,
                              optimal_ratio = optimal_ratio,
                              threshold_deviation = threshold_deviation,
                              n_feeding_events = n_feeding_events,
                              n_individuals = n_individuals,
                              initial_nutrients = initial_nutrients,
                              return_class = return_class)
  
  
head(gf_df1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Feeding_event Individual Nutrient1 Nutrient2 Item_in_diet
## 1             1          1         1         1            3
## 2             2          1         2         2            3
## 3             3          1         5         3            1
## 4             4          1         6         4            3
## 5             5          1         9         5            1
## 6             6          1        10         8            2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We illustrate the nutrient acquisition over feeding events with equally highly available items in the individuals environment.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_point(aes(x = Nutrient1, y = Nutrient2, color = Individual),
             alpha = 0.7, data = gf_df1) +
  geom_line(aes(x = optimal_protein, y = optimal_carbohydrates)) +
  ylim(0, 200) +
  theme(legend.position = &amp;quot;none&amp;quot;) +
  labs(title = &amp;quot;Nutrient acquisition when all items are equally scarce&amp;quot;,
       x = &amp;quot;Units Proteins&amp;quot;,
       y = &amp;quot;Units Carbohydrates&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:fig-acq-sc1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;staticfig-acq-sc1-1.png&#34; alt=&#34;Scenario 1 (items are equally scare) nutrient acquisition. The plot shows the acquisition of proteins on the x-axis in relation to the acquisition of carbohydrates on the y-axis over feeding events. The individuals nutrient acquisition is highlighted as dots. Different colors distinguish the simulated individuals. The nutritional goal of the individuals is highlighted as black line&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 5: Scenario 1 (items are equally scare) nutrient acquisition. The plot shows the acquisition of proteins on the x-axis in relation to the acquisition of carbohydrates on the y-axis over feeding events. The individuals nutrient acquisition is highlighted as dots. Different colors distinguish the simulated individuals. The nutritional goal of the individuals is highlighted as black line
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Figure &lt;a href=&#34;#fig:fig-acq-sc1&#34;&gt;5&lt;/a&gt; illustrates that the cumulative nutrient acquisition of our simulated individuals deviates from the target ratio when all items are equally scarce in the environment. The nutritional goal of our simulated animals is to consume 2P:1C. We included two items (item 2 with 1P:3C and item 3 with 1P:1C) that would lead to a higher carbohydrate consumption compared to the nutrient target, and one item (item 1 with a 3P:1C) that would lead to a higher protein consumption compared to the nutrient target.&lt;/p&gt;
&lt;p&gt;When animals experience food scarcity they are not able to maintain their target ratio, but still consume more units proteins than expected by the relative availability. Especially in the first few feeding events, when the total nutrient acquisition is still low, they stay closer to the target ratio compared to later feeding events when already many nutrients have been consumed. Individuals become less selective the more total nutrients they have already consumed.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;scenario-2-only-item-1-abundant&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Scenario 2: Only item 1 abundant&lt;/h3&gt;
&lt;p&gt;In this scenario we set Item 1 (3P:1C) to a high availability of 0.8, whereas item 2 (1P:3C) and item 3 (1P:1C) are both set to a low availability of 0.2.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;items_availability_scenario2 &amp;lt;- c(0.8, 0.2, 0.2)

gf_df2 &amp;lt;- geometric_framework(items_nutrients = items_nutrients,
                              items_availability = items_availability_scenario2,
                              optimal_ratio = optimal_ratio,
                              threshold_deviation = threshold_deviation,
                              n_feeding_events = n_feeding_events,
                              n_individuals = n_individuals,
                              initial_nutrients = initial_nutrients,
                              return_class = return_class)

  
head(gf_df2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Feeding_event Individual Nutrient1 Nutrient2 Item_in_diet
## 1             1          1         3         1            1
## 2             2          1         6         2            1
## 3             3          1         9         3            1
## 4             4          1        12         4            1
## 5             5          1        15         5            1
## 6             6          1        18         6            1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We illustrate the nutrient acquisition over feeding events with only item 1, which has a high protein content and is abundant in the individuals’ environment. The remaining items are scarce.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_point(aes(x = Nutrient1, y = Nutrient2, color = Individual),
             alpha = 0.7, data = gf_df2) +
  geom_line(aes(x = optimal_protein, y = optimal_carbohydrates)) +
    ylim(0, 200) +
  theme(legend.position = &amp;quot;none&amp;quot;) +
  labs(title = &amp;quot;Nutrient acquisition when only item 1 (3P:1C) is abundant&amp;quot;,
       x = &amp;quot;Units Proteins&amp;quot;,
       y = &amp;quot;Units Carbohydrates&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:fig-acq-sc2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;staticfig-acq-sc2-1.png&#34; alt=&#34;Scenario 2 (only item 1 (3P:1C) is abundant) nutrient acquisition. The plot shows the acquisition of proteins on the x-axis in relation to the acquisition of carbohydrates on the y-axis over feeding events. The individuals nutrient acquisition is highlighted as dots. Different colors distinguish the simulated individuals. The nutritional goal of the individuals is highlighted as black line&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 6: Scenario 2 (only item 1 (3P:1C) is abundant) nutrient acquisition. The plot shows the acquisition of proteins on the x-axis in relation to the acquisition of carbohydrates on the y-axis over feeding events. The individuals nutrient acquisition is highlighted as dots. Different colors distinguish the simulated individuals. The nutritional goal of the individuals is highlighted as black line
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Figre &lt;a href=&#34;#fig:fig-acq-sc2&#34;&gt;6&lt;/a&gt; illustrates that the cumulative nutrient acquisition of our simulated individuals deviates from the target ratio when only item 1, which provides the highest ratio of proteins compared to carbohydrates (3P:1C), is abundant in the environment. The nutritional goal of our simulated animals is to consume proteins and carbohydrates in a 2 to 1 ratio. We included two items (item 2 with a 1P:3C and item 3 with 1P:1C) that would lead to a higher carbohydrate consumption compared to the nutrient target, and one item (item 1 with a 3P:1C ) that would lead to a higher protein consumption compared to the nutrient target.&lt;/p&gt;
&lt;p&gt;If animals are provided with enough protein sources (item 1 abundant) they maintain their target ratio. Especially in the first few feeding events, when the total nutrient acquisition is still low, staying close to the target ratio is more important than in later feeding events when already many nutrients have been consumed. As before, individuals become less picky the more they have consumed.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;scenario-3-only-item-2-abundant&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Scenario 3: Only item 2 abundant&lt;/h3&gt;
&lt;p&gt;In this scenario we set Item 2 (1P:3C) to a high availability of 0.8, whereas item 1 (3P:1C) and item 3 (1P:1C) are both set to a low availability of 0.2.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;items_availability_scenario3 &amp;lt;- c(0.2, 0.8, 0.2)

gf_df3 &amp;lt;- geometric_framework(items_nutrients = items_nutrients,
                              items_availability = items_availability_scenario3,
                              optimal_ratio = optimal_ratio,
                              threshold_deviation = threshold_deviation,
                              n_feeding_events = n_feeding_events,
                              n_individuals = n_individuals,
                              initial_nutrients = initial_nutrients,
                              return_class = return_class)

head(gf_df3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Feeding_event Individual Nutrient1 Nutrient2 Item_in_diet
## 1             1          1         1         1            3
## 2             2          1         2         2            3
## 3             3          1         5         3            1
## 4             4          1         6         4            3
## 5             5          1         7         7            2
## 6             6          1         8        10            2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We illustrate the nutrient acquisition over feeding events with only item 2, which has a high carbohydrate content and is abundant in the individuals’ environment. The remaining items are scarce.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_point(aes(x = Nutrient1, y = Nutrient2, color = Individual),
             alpha = 0.7, data = gf_df3) +
  geom_line(aes(x = optimal_protein, y = optimal_carbohydrates)) +
    ylim(0, 200) +
  theme(legend.position = &amp;quot;none&amp;quot;) +
  labs(title = &amp;quot;Nutrient acquisition when only item 2 (1P:3C) is abundant&amp;quot;,
       x = &amp;quot;Units Proteins&amp;quot;,
       y = &amp;quot;Units Carbohydrates&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:fig-acq-sc3&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;staticfig-acq-sc3-1.png&#34; alt=&#34;Scenario 3 (only item 2 (1P:3C) is abundant) nutrient acquisition. The plot shows the acquisition of proteins on the x-axis in relation to the acquisition of carbohydrates on the y-axis over feeding events. The individuals nutrient acquisition is highlighted as dots. Different colors distinguish the simulated individuals. The nutritional goal of the individuals is highlighted as black line&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 7: Scenario 3 (only item 2 (1P:3C) is abundant) nutrient acquisition. The plot shows the acquisition of proteins on the x-axis in relation to the acquisition of carbohydrates on the y-axis over feeding events. The individuals nutrient acquisition is highlighted as dots. Different colors distinguish the simulated individuals. The nutritional goal of the individuals is highlighted as black line
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Figure &lt;a href=&#34;#fig:fig-acq-sc3&#34;&gt;7&lt;/a&gt; illustrates that the cumulative nutrient acquisition of our simulated individuals deviates from the target ratio when only item 1, which provides the highest ratio of proteins compared to carbohydrates, is abundant in the environment.The nutritional goal of our simulated animals is to consume proteins and carbohydrates in a 2 to 1 ratio. We included two items (item 2 with a 1P:3C and item 3 with 1P:1C) that would lead to a higher carbohydrate consumption compared to the nutrient target, and one item (item 1 with 3P:1C) that would lead to a higher protein consumption compared to the nutrient target.&lt;/p&gt;
&lt;p&gt;If animals are limited in their protein source (item 1 scarce) and primarily encounter carbohydrates while moving through their nutritional landscape (only item 2 abundant) they can’t maintain their target ratio and over consume carbohydrates.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this example, we only included 3 items and simulated animals that aim to follow a nutritional ratio of 2P:1C. We included two items (item 2 with 1P:3C and item 3 with 1P:1C ) that would lead to a higher carbohydrate consumption compared to the nutrient target, and one item (item 1 with 3P:1C) that would lead to a higher protein consumption compared to the nutrient target. Under our set conditions, the animals can only maintain their target ratio when item 1 is more abundant than the other items (Scenario 2). The animals deviate from the target ratio when there is protein scarcity (Scenario 1) and especially when they primarily encounter items with different nutritional signatures, they may reach their limiting deviation to the optimal nutrient ratio (Scenario 3), while moving through their nutritional landscape.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Part 2&lt;/strong&gt; we explore how well commonly used preference measures (namely electivity indices) can capture the preference of animals following Geometric Framework Models for different food items and how preference might change depending on resource limitations.&lt;/p&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34; line-spacing=&#34;2&#34;&gt;
&lt;div id=&#34;ref-lambert2015&#34; class=&#34;csl-entry&#34;&gt;
Lambert, J. E., &amp;amp; Rothman, J. M. (2015). Fallback Foods, Optimal Diets, and Nutritional Targets: Primate Responses to Varying Food Availability and Quality. &lt;em&gt;Annual Review of Anthropology&lt;/em&gt;, &lt;em&gt;44&lt;/em&gt;(1), 493–512. &lt;a href=&#34;https://doi.org/10.1146/annurev-anthro-102313-025928&#34;&gt;https://doi.org/10.1146/annurev-anthro-102313-025928&lt;/a&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-manly2007&#34; class=&#34;csl-entry&#34;&gt;
Manly, B. F. J., McDonald, L. L., Thomas, D. L., McDonald, T. L., &amp;amp; Erickson, W. P. (2007). &lt;em&gt;Resource Selection by Animals&lt;/em&gt;. 231.
&lt;/div&gt;
&lt;div id=&#34;ref-simpson2011&#34; class=&#34;csl-entry&#34;&gt;
Simpson, S. J., &amp;amp; Raubenheimer, D. (2011). The nature of nutrition: a unifying framework. &lt;em&gt;Australian Journal of Zoology&lt;/em&gt;, &lt;em&gt;59&lt;/em&gt;(6), 350. &lt;a href=&#34;https://doi.org/10.1071/ZO11068&#34;&gt;https://doi.org/10.1071/ZO11068&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Download and illustrate current and projected climate data in R</title>
      <link>https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/</guid>
      <description>


&lt;p&gt;Current climate data, and projections how climate may change in the (near) future, are important for various reasons. For example, such data can be used to predict how habitat suitability for different animal and plant species or agricultural productivity changes over time.&lt;/p&gt;
&lt;p&gt;Thus, in this post, I am showing how to get data on recent and projected climate directly into R, crop the obtained object to the area of interest (here: South America), and then calculate and illustrate the projected change. These data can then be used for further analyses in R.&lt;/p&gt;
&lt;p&gt;The data are taken from &lt;a href=&#34;http://worldclim.org&#34;&gt;worldclim.org&lt;/a&gt;, which provides climate projections from global climate models (GCM) following the Coupled Model Intercomparison Projects 5 (CMIP5) protocol. These models were used for the &lt;a href=&#34;https://www.ipcc.ch/assessment-report/ar5/&#34;&gt;5th report of the Intergovernmental Panel on Climate Change (IPCC) published in 2014&lt;/a&gt;. New models are currently developed following CMIP6, and will be used for the 6th IPCC report. I hope/guess that there will be soon an easy way to get these newer predictions into R (please leave a comment if you know about such a way).&lt;/p&gt;
&lt;p&gt;For the GCMs, there are four representative concentration pathways (RCPs) describing different climate futures depending on the emitted volumes of greenhouse gases. I am using RCP 4.5 here, which assumes a peak decline in green house gases around 2040, followed by decreasing emission. This is a rather optimistic scenario.&lt;/p&gt;
&lt;p&gt;Here are the different steps:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Use the &lt;code&gt;getData&lt;/code&gt; function from the &lt;code&gt;raster&lt;/code&gt; package to get climate data into R.&lt;/li&gt;
&lt;li&gt;Get a map of South America with the &lt;code&gt;rnaturalearth&lt;/code&gt; and &lt;code&gt;sf&lt;/code&gt; packages.&lt;/li&gt;
&lt;li&gt;Crop the climate data to South America and calculate projected changes with the &lt;code&gt;stars&lt;/code&gt; package.&lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;ggplot&lt;/code&gt; and &lt;code&gt;patchwork&lt;/code&gt; packages to illustrate the changes.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Some additional resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r-spatial.github.io/stars/articles/stars1.html&#34;&gt;Vignettes of the &lt;code&gt;stars&lt;/code&gt; package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;Vignettes of the &lt;code&gt;sf&lt;/code&gt; package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://geocompr.robinlovelace.net/&#34;&gt;Online book on &lt;em&gt;Geocomputation with R&lt;/em&gt;&lt;/a&gt; by Lovelace, Nowosad, and Muenchow&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;get-climate-data-with-rastergetdata&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1. Get climate data with &lt;code&gt;raster::getData&lt;/code&gt;&lt;/h2&gt;
&lt;div id=&#34;prepare-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.1 Prepare R&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list = ls())
library(stars)      # To process the raster data
library(sf)         # To work with vector data
library(ggplot2)    # For plotting
library(patchwork)  # To combine different ggplot plots&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Additional packages that are used: &lt;code&gt;raster&lt;/code&gt; (to get the climate data), &lt;code&gt;rnaturalearth&lt;/code&gt; (to get the map of South America).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;get-recent-climate-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.2 Get recent climate data&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;getData&lt;/code&gt; function from the &lt;code&gt;raster&lt;/code&gt; package makes it possible to easily download data on past, current/recent, and projected climate (and some other global geographic data sets. See &lt;code&gt;?raster::getData&lt;/code&gt; for details).&lt;/p&gt;
&lt;p&gt;Here, I am downloading interpolations of observed data representative for the period 1960-1990 (it is also possible to get data for the period 1970-2000). To do so, I am using the following arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name = &#39;worldclim&#39;&lt;/code&gt; to download data from &lt;a href=&#34;http://worldclim.org&#34;&gt;worldclim.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var = &#39;bio&#39;&lt;/code&gt; to get annual averages for all available climate variables. Other possibilities are, &lt;em&gt;e.g.&lt;/em&gt;, ‘tmin’ or ‘tmax’ for monthly minimum and maximum temperature.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res = 10&lt;/code&gt; for the resolution of 10 minutes of degree. This downloads the global data set. For higher resolutions (e.g., 2.5), the tile(s) have to be specified (with &lt;code&gt;lon&lt;/code&gt; and &lt;code&gt;lat&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; specifies that files are downloaded into subfolder ‘/blog_data’. For this dataset, the files ‘bio1.bil’ to ‘bio19.bil’ (plus ‘.hdr’ files) will be downloaded to ‘/blog_data/wc10/’.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;file_path &amp;lt;- paste0(dirname(here::here()), &amp;quot;/blog_data/&amp;quot;)
raster::getData(name = &amp;#39;worldclim&amp;#39;, var = &amp;#39;bio&amp;#39;, res = 10,
        path = file_path)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterStack 
## dimensions : 900, 2160, 1944000, 19  (nrow, ncol, ncell, nlayers)
## resolution : 0.1666667, 0.1666667  (x, y)
## extent     : -180, 180, -60, 90  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
## names      :  bio1,  bio2,  bio3,  bio4,  bio5,  bio6,  bio7,  bio8,  bio9, bio10, bio11, bio12, bio13, bio14, bio15, ... 
## min values :  -269,     9,     8,    72,   -59,  -547,    53,  -251,  -450,   -97,  -488,     0,     0,     0,     0, ... 
## max values :   314,   211,    95, 22673,   489,   258,   725,   375,   364,   380,   289,  9916,  2088,   652,   261, ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;get-projected-climate-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.3 Get projected climate data&lt;/h3&gt;
&lt;p&gt;To get climate data projected for the period 2061-2080, I am using the following arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name = &#39;CMIP5&#39;&lt;/code&gt; to get data from the CMIP5 models.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var = &#39;bio&#39;&lt;/code&gt;, which includes the same 19 variables for annual averages as for ‘worldclim’ (the set of variables other than ‘bio’ is very limited for ‘CMIP5’).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res = 10&lt;/code&gt; as above.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rcp = 45&lt;/code&gt; (see introduction)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model = &#39;IP&#39;&lt;/code&gt; (the ‘IPSL-CM5A-LR’ model). Check &lt;code&gt;?raster::getData&lt;/code&gt; for a list of all models. Perhaps, downloading all/a subset of models and then average projections is better than using a single model, but for the sake of simplicity, I only download this single model here.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;year = 70&lt;/code&gt; to get projections for the period 2061-2080 (alternative is 50).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; as above. Files ‘ip45bi701.tif’- ‘ip45bi7019.tif’ will be downloaded to ‘/blog_data/cmip5/10m/’.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;raster::getData(name = &amp;#39;CMIP5&amp;#39;, var = &amp;#39;bio&amp;#39;, res = 10,
        rcp = 45, model = &amp;#39;IP&amp;#39;, year = 70,
        path = file_path)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## class      : RasterStack 
## dimensions : 900, 2160, 1944000, 19  (nrow, ncol, ncell, nlayers)
## resolution : 0.1666667, 0.1666667  (x, y)
## extent     : -180, 180, -60, 90  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs 
## names      : ip45bi701, ip45bi702, ip45bi703, ip45bi704, ip45bi705, ip45bi706, ip45bi707, ip45bi708, ip45bi709, ip45bi7010, ip45bi7011, ip45bi7012, ip45bi7013, ip45bi7014, ip45bi7015, ... 
## min values :      -227,       -60,       -80,        86,       -22,      -512,        53,      -215,      -421,        -60,       -455,          0,          0,          0,          0, ... 
## max values :       344,       217,        94,     22678,       524,       283,       729,       415,       401,        421,        320,      10541,       2701,        489,        222, ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;load-and-process-temperature-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.4 Load and process temperature data&lt;/h3&gt;
&lt;p&gt;The first variable from ‘bio’ is annual average temperature in 10 * °C. For recent data, the file name for this variable is ‘bio1.bil’, and for projected data ‘ip45bi701.tif’. Both can be loaded with the &lt;code&gt;read_stars&lt;/code&gt; function from the &lt;code&gt;stars&lt;/code&gt; package. Values have to be divided by 10 to get the temperature in °C (instead of 10 * °C)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;annual_T &amp;lt;- stars::read_stars(paste0(file_path, &amp;quot;wc10/bio1.bil&amp;quot;))
annual_T &amp;lt;- annual_T/10
annual_T_70 &amp;lt;- stars::read_stars(paste0(file_path, &amp;quot;cmip5/10m/ip45bi701.tif&amp;quot;))
annual_T_70 &amp;lt;- annual_T_70/10&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;quick-plots&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.5 Quick Plots&lt;/h3&gt;
&lt;p&gt;For the plots, I am defining a color palette for temperature. Colors are taken from the “5-class RdYlBu” palette from &lt;a href=&#34;http://colorbrewer2.org&#34; class=&#34;uri&#34;&gt;http://colorbrewer2.org&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# The result, temp_colors, is a function with argument n for the number of
# colors.
temp_colors &amp;lt;- colorRampPalette(c(&amp;quot;#2c7bb6&amp;quot;, &amp;quot;#abd9e9&amp;quot;, &amp;quot;#ffffbf&amp;quot;, &amp;quot;#fdae61&amp;quot;, &amp;quot;#d7191c&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, global maps can be plotted with this color palette:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nbreaks &amp;lt;- 20
{
  par(mfrow = c(1,2))
  plot(annual_T, main = &amp;quot;Annual temperature - 1960-1990&amp;quot;,
     nbreaks = nbreaks,
     col = temp_colors(nbreaks - 1))
  plot(annual_T_70, main = &amp;quot;Annual temperature - RCP 4.5 projection for 2061-2080&amp;quot;,
     nbreaks = nbreaks,
     col = temp_colors(nbreaks - 1))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/index_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/index_files/figure-html/unnamed-chunk-6-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Colors are not directly comparable between the two maps!&lt;/strong&gt; The temperature range of each data set is used to define the color range for each map. Thus, in each map, the bluest color indicates the coolest temperature and the reddest color the hottest temperature, which differ between the two maps. This will be fixed in the plot below.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;get-map-of-south-america&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2. Get Map of South America&lt;/h2&gt;
&lt;p&gt;Get all countries from South America with the &lt;code&gt;rnaturalearth&lt;/code&gt; package, and then combine them to a single shape.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;south_america_map &amp;lt;- rnaturalearth::ne_countries(continent = &amp;quot;south america&amp;quot;, returnclass = &amp;quot;sf&amp;quot;)
# The precision has to be set to a value &amp;gt; 0 to resolve internal boundaries.
st_precision(south_america_map) &amp;lt;- 1e9 # Required to
south_america_map &amp;lt;- st_union(south_america_map)

{
par(mar = c(0,0,0,0))
plot(south_america_map)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/index_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;climate-of-south-america&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3. Climate of South America&lt;/h2&gt;
&lt;div id=&#34;crop-climate-raster-data-to-area-of-south-america&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.1 Crop climate raster data to area of South America&lt;/h3&gt;
&lt;p&gt;To crop a raster with the &lt;code&gt;stars&lt;/code&gt; package, square brackets &lt;code&gt;[]&lt;/code&gt; will work as crop operator (see &lt;a href=&#34;https://r-spatial.github.io/stars/articles/stars1.html&#34;&gt;here&lt;/a&gt; for details).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;annual_T_SA &amp;lt;- annual_T[south_america_map]
# CRS for projected T and south america map are the same (EPSG 4326) but the
# proj4string includes more details for annual_T_70. Thus, they have to
# be made identical before cropping.
st_crs(annual_T_70) &amp;lt;- st_crs(south_america_map)
annual_T_70_SA &amp;lt;- annual_T_70[south_america_map]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Quick plots:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;{
  par(mfrow = c(1, 2))
  plot(annual_T_SA, main = &amp;quot;Annual temperature - 1960-1990&amp;quot;,
       nbreaks = nbreaks,
       col = temp_colors(nbreaks - 1))
  plot(main = &amp;quot;Annual temperature - RCP 4.5 projection for 2061-2080&amp;quot;,
       annual_T_70_SA, nbreaks = nbreaks,
       col = temp_colors(nbreaks - 1))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/index_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/index_files/figure-html/unnamed-chunk-9-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;get-some-basic-summaries&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.2 Get some basic summaries&lt;/h3&gt;
&lt;p&gt;The print method for &lt;code&gt;stars&lt;/code&gt; objects provides some summary statistics, such as max, min, or median temperature.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;annual_T_SA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## stars object with 2 dimensions and 1 attribute
## attribute(s):
##    bio1.bil     
##  Min.   :-6.50  
##  1st Qu.:17.60  
##  Median :24.00  
##  Mean   :21.03  
##  3rd Qu.:26.00  
##  Max.   :29.00  
##  NA&amp;#39;s   :59262  
## dimension(s):
##   from  to offset     delta                       refsys point values    
## x  592 872   -180  0.166667 +proj=longlat +datum=WGS8...    NA   NULL [x]
## y  466 874     90 -0.166667 +proj=longlat +datum=WGS8...    NA   NULL [y]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But these values can also be manually calculated. For example, the mean temperature in South America for the period 1960 - 1990 is:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean(annual_T$bio1.bil, na.rm = T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8.144672&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Currently, &lt;code&gt;bio1.bil&lt;/code&gt; is the only attribute (&lt;em&gt;i.e.&lt;/em&gt;, the variable with recent annual temperature) in the &lt;code&gt;annual_T&lt;/code&gt; object, but &lt;code&gt;stars&lt;/code&gt; objects can also include several attributes.&lt;/p&gt;
&lt;p&gt;Here, I will rename this attribute to &lt;code&gt;recent&lt;/code&gt;. Then I will add the projected temperature from the other object (&lt;code&gt;annual_T_70_SA$ip45bi701.tif&lt;/code&gt;) as a second attribute &lt;code&gt;projected&lt;/code&gt;. Finally, I will calculate the difference between the two, which is the projected change.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(annual_T_SA) &amp;lt;- &amp;quot;recent&amp;quot;
annual_T_SA$projected &amp;lt;- annual_T_70_SA$ip45bi701.tif
annual_T_SA$change &amp;lt;- annual_T_SA$projected  - annual_T_SA$recent
annual_T_SA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## stars object with 2 dimensions and 3 attributes
## attribute(s):
##     recent         projected        change      
##  Min.   :-6.50   Min.   :-4.00   Min.   :1.00   
##  1st Qu.:17.60   1st Qu.:20.10   1st Qu.:2.50   
##  Median :24.00   Median :26.80   Median :2.80   
##  Mean   :21.03   Mean   :23.76   Mean   :2.73   
##  3rd Qu.:26.00   3rd Qu.:28.80   3rd Qu.:3.00   
##  Max.   :29.00   Max.   :31.70   Max.   :4.40   
##  NA&amp;#39;s   :59262   NA&amp;#39;s   :59262   NA&amp;#39;s   :59262  
## dimension(s):
##   from  to offset     delta                       refsys point values    
## x  592 872   -180  0.166667 +proj=longlat +datum=WGS8...    NA   NULL [x]
## y  466 874     90 -0.166667 +proj=longlat +datum=WGS8...    NA   NULL [y]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;illustrate-changes-in-temperature-with-ggplot-and-patchwork&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4. Illustrate changes in temperature with &lt;code&gt;ggplot&lt;/code&gt; and &lt;code&gt;patchwork&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Here, we can use &lt;code&gt;scale_fill_gradientn&lt;/code&gt; to define temperature colors, and then use the same limits for both plots. Now, colors are directly comparable between the plots for annual temperature. I will only use red colors for the change in temperature, as these values are always positive.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;recent_T_plot &amp;lt;- ggplot() + 
  geom_stars(data = annual_T_SA) +
  scale_fill_gradientn(name = &amp;quot;Annual T [°C]&amp;quot;,
                       colors = temp_colors(5),
                       limits = c(-7, 32),
                       na.value = &amp;quot;white&amp;quot;) +
  geom_sf(data = south_america_map, fill = NA) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  ggtitle(&amp;quot;a) 1960-1990&amp;quot;) +
  theme_void() +
  theme(legend.position = &amp;quot;none&amp;quot;)

projected_T_plot &amp;lt;- ggplot() + 
  geom_stars(data = annual_T_SA[&amp;quot;projected&amp;quot;]) +
  scale_fill_gradientn(name = &amp;quot;Annual T [°C]&amp;quot;,
                       colors = temp_colors(5),
                       limits = c(-7, 32),
                       na.value = &amp;quot;white&amp;quot;) +
  geom_sf(data = south_america_map, fill = NA) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  ggtitle(&amp;quot;b) 2061-2080 (projected)&amp;quot;) +
  theme_void() +
  theme(legend.position = &amp;quot;bottom&amp;quot;)

projected_change_T_plot &amp;lt;- ggplot() + 
  geom_stars(data = annual_T_SA[&amp;quot;change&amp;quot;]) +
  scale_fill_gradientn(name = &amp;quot;Change in T [°C]&amp;quot;,
                       colors = temp_colors(5)[3:5],
                       limits = c(1, 5),
                       na.value = &amp;quot;white&amp;quot;) +
  geom_sf(data = south_america_map, fill = NA) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  ggtitle(&amp;quot;c) Projected change&amp;quot;) +
  theme_void() +
  theme(legend.position = &amp;quot;bottom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, I will combine the three maps with the &lt;code&gt;patchwork&lt;/code&gt; package (see &lt;a href=&#34;https://patchwork.data-imaginist.com/articles/patchwork.html&#34;&gt;here&lt;/a&gt; for details).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(recent_T_plot / projected_T_plot + plot_layout(guides = &amp;quot;keep&amp;quot;)) | projected_change_T_plot +
  theme(plot.margin = margin(c(0, 0, 0, 0)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/download-and-illustrate-current-and-projected-climate-in-r/index_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>African Mammals</title>
      <link>https://bedatablog.netlify.com/post/african-mammals-map/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://bedatablog.netlify.com/post/african-mammals-map/</guid>
      <description>


&lt;p&gt;Interested in the distribution of animal species on a global or continental level? This can be easily illustrated with R using the data provided by the &lt;a href=&#34;https://www.iucnredlist.org&#34;&gt;IUCN Red List&lt;/a&gt;. In this post, I will focus on mammals in Africa, the continent where I have conducted most of my field work. But the code below can be easily adapted to other areas of the world and other taxonomic groups of species, or only species at low or high risk of extinction (though the completeness of the IUCN data is variable across different groups).&lt;/p&gt;
&lt;p&gt;In this post, I describe the following steps:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Download and process the &lt;em&gt;IUCN Red List&lt;/em&gt; spatial data set for terrestrial mammals&lt;/li&gt;
&lt;li&gt;Download a map of Africa&lt;/li&gt;
&lt;li&gt;Create a hexagon grid for Africa&lt;/li&gt;
&lt;li&gt;Combine species ranges with the grid and plot the map&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The processing and summarizing of the spatial data is mostly done with the impressive &lt;code&gt;sf&lt;/code&gt; package. For my first attempts to work with spatial data in R (more specifically with vector data), I used the &lt;code&gt;sp&lt;/code&gt; package. But the &lt;code&gt;sf&lt;/code&gt; package, which is the successor of the &lt;code&gt;sp&lt;/code&gt;, is much easier to use. Additionally, it integrates some of the &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;&lt;code&gt;tidyverse&lt;/code&gt;&lt;/a&gt; functions, most importantly many of the &lt;code&gt;dplyr&lt;/code&gt; functions, which so many R users are already using for other purposes. Also, the &lt;code&gt;sf&lt;/code&gt; package is very well documented and the vignettes are extremely helpful. They can be found on the &lt;a href=&#34;https://github.com/r-spatial/sf&#34;&gt;github page of the package&lt;/a&gt; or by typing &lt;code&gt;vignette(package = &amp;quot;sf&amp;quot;)&lt;/code&gt;. I also would like to mention the book &lt;a href=&#34;https://geocompr.robinlovelace.net&#34;&gt;‘Geocomputation with R’&lt;/a&gt;, which is a very informative (open source) resource for anybody interested in working with spatial data in R.&lt;/p&gt;
&lt;div id=&#34;download-and-process-the-iucn-red-list-spatial-data-set-for-terrestrial-mammals&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1. Download and process the &lt;em&gt;IUCN Red List&lt;/em&gt; spatial data set for terrestrial mammals&lt;/h2&gt;
&lt;div id=&#34;prepare-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.1 Prepare R&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list = ls())
library(tidyverse)
library(sf)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;download-and-process-the-iucn-terrestial-mammals-shapefile&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.2 Download and process the &lt;em&gt;IUCN&lt;/em&gt; terrestial mammals shapefile&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;IUCN Red List&lt;/em&gt; spatial data can be obtained &lt;a href=&#34;https://www.iucnredlist.org/resources/spatial-data-download&#34;&gt;here&lt;/a&gt;. The &lt;em&gt;IUCN&lt;/em&gt; datasets are freely available for non-commercial use, but they have to be downloaded manually because you have to register for an account and provide a description of the intended usage. For academic use, you can (usually) download the dataset immediately after you made your request.&lt;/p&gt;
&lt;p&gt;The ranges of populations and species are all provided as polygons in the downloadable shapefiles. However, some species might be missing, and some ranges might be incomplete. Nevertheless, it is an impressive data set, and at least for primates, it looks fairly complete. Further details (and limitations) can be found on the &lt;em&gt;IUCN&lt;/em&gt; spatial data webpage.&lt;/p&gt;
&lt;p&gt;For this post, I downloaded the “Terrestrial Mammal” datasets, which is about ~ 600 MB. Then, I moved the downloaded folder (‘TERRESTRIAL_MAMMALS’) into the folder “~/Sync/iucn_data/” on my harddrive and renamed it to ‘TERRESTRIAL_MAMMALS_2020_01_11’.&lt;/p&gt;
&lt;p&gt;I split up the following process into two steps: 1) load, simplify (&lt;em&gt;i.e.&lt;/em&gt;, reduce the size of the object), and save the processed shapefile a .gpkg file; and 2) re-load the processed files. The first step will not be evaluated in the final notebook so that the 600 MB shapefile does not have to be processed every time I run this notebook.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mammals &amp;lt;- st_read(&amp;quot;~/Sync/iucn_data/TERRESTRIAL_MAMMALS_2020_01_11&amp;quot;)

# Simplify the polygons to reduce the size of the object/file. This may take a
# few moments but the size of the object (in the R environment) changes from 906
# Mb to &amp;lt;10 Mb (with dTolerance = 5), which is much easier to handle.
mammals_simple &amp;lt;- mammals %&amp;gt;% 
  st_simplify(dTolerance = 1)

mammals_simple &amp;lt;- mammals_simple %&amp;gt;% 
  select(binomial, presence,legend, category)

# Write the object to a file and clean up. I use .gpkg extension here because it
# just requires one file instead of several files created for shapefiles. Also,
# it&amp;#39;s an open format and it appears to be just as good as shapefiles (at least
# for everything I&amp;#39;ve done so far). Look here for more information:
# https://www.gis-blog.com/geopackage-vs-shapefile/
file_name &amp;lt;- paste0(dirname(here::here()), &amp;quot;/blog_data/iucn_mammal_distribution.gpkg&amp;quot;)
st_write(mammals_simple, file_name)
rm(list = c(&amp;quot;mammals&amp;quot;, &amp;quot;mammals_simple&amp;quot;, &amp;quot;file_name&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; I set the &lt;code&gt;dTolerance&lt;/code&gt; argument to 1, but for a more precise map, it might be good to change it to 0.1 or a lower value.&lt;br /&gt;
Also, I only kept four of the columns: &lt;code&gt;binomial&lt;/code&gt; (the species name), &lt;code&gt;presence&lt;/code&gt; and &lt;code&gt;legend&lt;/code&gt; (indicating whether a population is still present), and &lt;code&gt;category&lt;/code&gt; (the risk category for each species). For other projects, additional columns can be added. For example, &lt;code&gt;order_&lt;/code&gt; or &lt;code&gt;family&lt;/code&gt; indicate the taxonomic order/family of a species.&lt;/p&gt;
&lt;p&gt;Now, load the file (step 2)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;file_name &amp;lt;- paste0(dirname(here::here()),
                    &amp;quot;/blog_data/iucn_mammal_distribution.gpkg&amp;quot;)
mammals &amp;lt;- st_read(file_name)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Reading layer `iucn_mammal_distribution&amp;#39; from data source `/Users/urs/Google Drive/Data Blog/blog_data/iucn_mammal_distribution.gpkg&amp;#39; using driver `GPKG&amp;#39;
## Simple feature collection with 12908 features and 4 fields (with 7579 geometries empty)
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -179.999 ymin: -56.04993 xmax: 179.999 ymax: 89.9
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Quick look at the &lt;code&gt;sf&lt;/code&gt; object:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(mammals)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 6 features and 4 fields (with 2 geometries empty)
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -58.02031 ymin: -43.29721 xmax: 153.0728 ymax: 50.38943
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
##                   binomial presence            legend category
## 1 Nyctereutes procyonoides        1 Extant (resident)       LC
## 2         Rattus lutreolus        1 Extant (resident)       LC
## 3     Rhinolophus subrufus        1 Extant (resident)       DD
## 4           Mops spurrelli        1 Extant (resident)       LC
## 5         Clyomys laticeps        1 Extant (resident)       LC
## 6       Eonycteris spelaea        1 Extant (resident)       LC
##                             geom
## 1 MULTIPOLYGON (((143.7874 50...
## 2 MULTIPOLYGON (((147.0231 -3...
## 3             MULTIPOLYGON EMPTY
## 4 MULTIPOLYGON (((16.12875 4....
## 5 MULTIPOLYGON (((-47.53412 -...
## 6             MULTIPOLYGON EMPTY&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For an explanation of sf objects, look at the &lt;a href=&#34;https://cran.r-project.org/web/packages/sf/vignettes/sf1.html&#34;&gt;first vignette of the sf package&lt;/a&gt;. Every row in this data frame represents one population of species &lt;code&gt;binomial&lt;/code&gt;, with additional information about the presence and risk category (columns &lt;code&gt;presence&lt;/code&gt;, &lt;code&gt;legend&lt;/code&gt;, and &lt;code&gt;category&lt;/code&gt;). The sf-column &lt;code&gt;geom&lt;/code&gt; contains the geographic information describing the range of each population. As far as I understand this data set, several populations might be combined into one row (the sf-column can contain several polygons), but in other cases, each population has its own row.&lt;/p&gt;
&lt;p&gt;We can simply plot all polygons (for all rows) with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;{
  par(mar = c(0, 0, 0, 0))
  plot(st_geometry(mammals))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/african-mammals-map/index_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This plot shows the distributions of all mammal species/populations, but it also includes populations that are no longer present. Let’s have a look at the different codes for &lt;code&gt;presence&lt;/code&gt; and the description, which can be found in the column &lt;code&gt;legend&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mammals %&amp;gt;%
  st_set_geometry(NULL) %&amp;gt;%
  distinct(presence, legend) %&amp;gt;% 
  arrange(presence)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    presence                                            legend
## 1         1                                 Extant (resident)
## 2         1                    Extant &amp;amp; Introduced (resident)
## 3         1                  Extant &amp;amp; Reintroduced (resident)
## 4         1          Extant &amp;amp; Vagrant (seasonality uncertain)
## 5         1              Extant &amp;amp; Origin Uncertain (resident)
## 6         1                    Extant (seasonality uncertain)
## 7         1                             Extant (non-breeding)
## 8         1                       Extant &amp;amp; Vagrant (resident)
## 9         2                        Probably Extant (resident)
## 10        2     Probably Extant &amp;amp; Origin Uncertain (resident)
## 11        2           Probably Extant &amp;amp; Introduced (resident)
## 12        3                        Possibly Extant (resident)
## 13        3     Possibly Extant &amp;amp; Origin Uncertain (resident)
## 14        3           Possibly Extant (seasonality uncertain)
## 15        3                         Possibly Extant (passage)
## 16        3 Possibly Extant &amp;amp; Vagrant (seasonality uncertain)
## 17        3           Possibly Extant &amp;amp; Introduced (resident)
## 18        3          Possibly Extant &amp;amp; Vagrant (non-breeding)
## 19        4                                  Possibly Extinct
## 20        4                     Possibly Extinct &amp;amp; Introduced
## 21        5                                           Extinct
## 22        5                        Extinct &amp;amp; Origin Uncertain
## 23        5                              Extinct &amp;amp; Introduced
## 24        5                            Extinct &amp;amp; Reintroduced
## 25        6                                Presence Uncertain
## 26        6             Presence Uncertain &amp;amp; Origin Uncertain
## 27        6                      Presence Uncertain &amp;amp; Vagrant&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Codes/numbers 1, 2, and 3 refer to ‘extant’, ‘probably extant’, and ‘possibly extant’ populations, and I only keep these populations here.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mammals_extant &amp;lt;- mammals %&amp;gt;% 
  filter(presence %in% c(1,2,3))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;download-a-map-of-africa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2. Download a map of Africa&lt;/h2&gt;
&lt;p&gt;In R, it’s very easy to get maps of countries or continents from &lt;a href=&#34;https://www.naturalearthdata.com&#34; class=&#34;uri&#34;&gt;https://www.naturalearthdata.com&lt;/a&gt; using the &lt;code&gt;rnaturalearth&lt;/code&gt; package. With the &lt;code&gt;ne_countries()&lt;/code&gt; function, all countries (as polygons) for the specified continent can be downloaded. Here, I am only interested in a map of the whole continent, not single countries. This can be achieved with the &lt;code&gt;dplyr::summarize()&lt;/code&gt; function, which ‘summarizes’ the polygons in all rows in the sf object (the countries) to one polygon (the continent). One of the examples showing how nicely the tidyverse functionality is integrated into the &lt;code&gt;sf&lt;/code&gt; package!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa_map &amp;lt;- rnaturalearth::ne_countries(continent = &amp;quot;Africa&amp;quot;,
                                          returnclass = &amp;quot;sf&amp;quot;) %&amp;gt;%
  st_set_precision(1e9) %&amp;gt;%
  summarize
{
  par(mar = c(0, 0, 0, 0))
  plot(st_geometry(africa_map))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/african-mammals-map/index_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;create-a-hexagon-grid-for-africa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3. Create a hexagon grid for Africa&lt;/h2&gt;
&lt;p&gt;Since I want to illustrate how species richness varies across regions, the number of species have to be summarized for some kind of (spatial) subsets of Africa. For example, this could be done by country. But here, I use a grid of equally sized hexagon cells to illustrate the varying species richness across the continent. This is possible with the &lt;code&gt;sf::st_make_grid()&lt;/code&gt; function. The argument &lt;code&gt;square = F&lt;/code&gt; specifies that hexagons are created instead of squares. Furthermore, I create a &lt;code&gt;grid_id&lt;/code&gt; column, which will be required as identifier for grid cells further below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa_grid &amp;lt;- st_make_grid(africa_map,
                            what = &amp;quot;polygons&amp;quot;,
                            cellsize = 0.75,
                            square = F) %&amp;gt;% 
  st_sf() %&amp;gt;% 
  mutate(grid_id = row_number())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: the cell size can be adjusted by changing the &lt;code&gt;cellsize&lt;/code&gt; argument, but this will also affect the number of species per cell. Larger cells are more likely to intersect with more species than smaller cells.&lt;/p&gt;
&lt;p&gt;For the map, I only want to keep the parts of the grid cells that are on the continent. This might be problematic in some cases because the cells at the edge of the continent are smaller than cells within the continent. But since I only summarize terrestrial mammals here, I think it might also be misleading if the cells cover non-terrestrial area without including marine mammals.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa_grid_clipped &amp;lt;- st_intersection(africa_grid, africa_map)

{
  par(mar = c(0, 0, 0, 0))
  plot(africa_map$geometry, reset = F, axes = F)
  plot(st_geometry(africa_grid_clipped), color = &amp;quot;white&amp;quot;,
       add = T, border = rgb(0, 0, 0, 0.3))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/african-mammals-map/index_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;combine-species-ranges-with-the-grid-and-plot-the-map&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4. Combine species ranges with the grid and plot the map&lt;/h2&gt;
&lt;div id=&#34;only-keep-population-ranges-within-africa&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.1 Only keep population ranges within Africa&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;st_intersection()&lt;/code&gt;, only the portion of population ranges within Africa are kept.
Then, ranges are ‘summarized’ by species, which means that for species with several rows in the data frame, these rows are combined into one row with a (multi) polygon describing the entire range of this species. The use of &lt;code&gt;dplyr::group_by()&lt;/code&gt; in combination with &lt;code&gt;dplyr::summarize()&lt;/code&gt; with an sf object is another great example for the integration of the tidyverse functionality in the sf package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;africa_mammals &amp;lt;- st_intersection(mammals, africa_map) %&amp;gt;% 
  group_by(binomial) %&amp;gt;% 
  summarize()
{
  par(mar = c(0, 0, 0, 0))
  plot(st_geometry(africa_mammals))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/african-mammals-map/index_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;combine-ranges-with-the-grid&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.2 Combine ranges with the grid&lt;/h3&gt;
&lt;p&gt;The range polygons can be combined with the grid map using the &lt;code&gt;sf::st_join()&lt;/code&gt; function. Then, the number of species is counted per grid cell using the &lt;code&gt;grid_id&lt;/code&gt; column created above.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# This may take a few minutes
species_per_cell &amp;lt;- africa_grid_clipped %&amp;gt;% 
  st_join(africa_mammals)

species_per_cell_sums &amp;lt;- species_per_cell %&amp;gt;% 
  group_by(grid_id) %&amp;gt;% 
  summarize(species_n = n())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-the-plot&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.3 Create the plot&lt;/h3&gt;
&lt;p&gt;The standard output with &lt;code&gt;plot()&lt;/code&gt; looks like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(species_per_cell_sums[&amp;quot;species_n&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/african-mammals-map/index_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The plot created with &lt;code&gt;plot()&lt;/code&gt; can be customized, but I find it easier to customize plots with the &lt;code&gt;ggplot2&lt;/code&gt; package. Therefore, I create another plot with &lt;code&gt;ggplot()&lt;/code&gt; using a different color palette, and applying some other modifications.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;african_mammals_map &amp;lt;- ggplot() +
  geom_sf(data = species_per_cell_sums,
          aes(fill = species_n),
          size = 0) +
  scale_fill_gradient2(name = &amp;quot;Number of\nSpecies&amp;quot;,
                       low = &amp;quot;#004529&amp;quot;,
                       mid = &amp;quot;#f7fcb9&amp;quot;,
                       high = &amp;quot;#7f0000&amp;quot;,
                       midpoint = max(species_per_cell_sums$species_n)/2) +
  geom_sf(data = africa_map, fill = NA) +
  labs(title = &amp;quot;Mammal Species in Africa&amp;quot;) +
  theme_void() +
  theme(legend.position = c(0.1, 0.1),
        legend.justification = c(0, 0),
        plot.title = element_text(hjust = .5))
african_mammals_map&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/african-mammals-map/index_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Creation and Detection of Clusters in Social Networks - Part 2</title>
      <link>https://bedatablog.netlify.com/post/social-clusters-ii/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://bedatablog.netlify.com/post/social-clusters-ii/</guid>
      <description>


&lt;p&gt;In the &lt;a href=&#34;https://bedatablog.netlify.com/social-clusters-I/&#34;&gt;previous post&lt;/a&gt;, I simulated clustered networks with varying strength of within-group, between-close-groups, and between-group social relationships. In part 2, I am using some of the methods provided by the &lt;code&gt;igraph&lt;/code&gt; package to test how well these simulated clusters can be (re)-detected.&lt;/p&gt;
&lt;div id=&#34;determine-clustering-using-different-methods-and-compare-the-results&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. Determine clustering using different methods and compare the results&lt;/h1&gt;
&lt;div id=&#34;prepare-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1 Prepare R&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list = ls())
library(tidyverse)
library(tidygraph)
library(ggraph)
library(igraph)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition to these packages, this notebook requires the installation of the following packages: &lt;code&gt;DT&lt;/code&gt;, &lt;code&gt;cowplot&lt;/code&gt;, &lt;code&gt;ggrepel&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;recreate-the-network-from-previous-post&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2 Recreate the network from previous post&lt;/h3&gt;
&lt;p&gt;To avoid repetition, the code is not shown here, but can be copied from the &lt;a href=&#34;https://bedatablog.netlify.com/social-clusters-I/&#34;&gt;previous post&lt;/a&gt;. The two objects that are required from there are &lt;code&gt;individual_df&lt;/code&gt; and &lt;code&gt;network_df&lt;/code&gt;.&lt;br /&gt;
The networks looked like that:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/social-clusters-II/index_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;One important note&lt;/em&gt;:&lt;/strong&gt; My motivation for this small project was my research on a group of ~50 adult red colobus monkeys. Therefore, I simulated networks where most individuals were somehow connected. The plot above, however, only shows association indices &lt;span class=&#34;math inline&#34;&gt;\(\ge\)&lt;/span&gt; 0.3 to make it easier to see the clusters. The complete network is much denser (see the final plot of this post). After finalizing the draft of this post, I realized that this may have affected how well (or not) the algorithms detected the (sub)-groups and therefore wanted to mention it here.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;use-different-algorithms-to-detect-clusters&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.3 Use different algorithms to detect clusters&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;igraph&lt;/code&gt;-package provides several functions to detect communities within a network, which start with &lt;code&gt;cluster_&lt;/code&gt; (type &lt;code&gt;?communities&lt;/code&gt; in R for a complete list). Most of these algorithms are explained &lt;a href=&#34;https://dshizuka.github.io/networkanalysis/05_community.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Before using the &lt;code&gt;cluster_&lt;/code&gt; functions, the networks have to be transformed into &lt;code&gt;igraph&lt;/code&gt; objects.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df_to_network &amp;lt;- function(network_df, weight_col){
  network &amp;lt;- graph_from_data_frame(select(network_df,
                                          from = Ind_A, to = Ind_B,
                                          weight = matches(weight_col)),
                              directed = FALSE)
  return(network)
}

network_1 &amp;lt;- df_to_network(network_df, weight_col = &amp;quot;S1&amp;quot;)
network_2 &amp;lt;- df_to_network(network_df, weight_col = &amp;quot;S2&amp;quot;)
network_3 &amp;lt;- df_to_network(network_df, weight_col = &amp;quot;S3&amp;quot;)
network_4 &amp;lt;- df_to_network(network_df, weight_col = &amp;quot;S4&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the standard output for such an object:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;network_1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## IGRAPH 1485755 UNW- 50 1225 -- 
## + attr: name (v/c), weight (e/n)
## + edges from 1485755 (vertex names):
##  [1] ind_01--ind_02 ind_01--ind_03 ind_01--ind_04 ind_01--ind_05 ind_01--ind_06
##  [6] ind_01--ind_07 ind_01--ind_08 ind_01--ind_09 ind_01--ind_10 ind_01--ind_11
## [11] ind_01--ind_12 ind_01--ind_13 ind_01--ind_14 ind_01--ind_15 ind_01--ind_16
## [16] ind_01--ind_17 ind_01--ind_18 ind_01--ind_19 ind_01--ind_20 ind_01--ind_21
## [21] ind_01--ind_22 ind_01--ind_23 ind_01--ind_24 ind_01--ind_25 ind_01--ind_26
## [26] ind_01--ind_27 ind_01--ind_28 ind_01--ind_29 ind_01--ind_30 ind_01--ind_31
## [31] ind_01--ind_32 ind_01--ind_33 ind_01--ind_34 ind_01--ind_35 ind_01--ind_36
## [36] ind_01--ind_37 ind_01--ind_38 ind_01--ind_39 ind_01--ind_40 ind_01--ind_41
## + ... omitted several edges&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here’s the output if one of the &lt;code&gt;cluster_&lt;/code&gt; functions is applied to a network, in this example the &lt;em&gt;fast-greedy&lt;/em&gt; algorithm to the first network (S1):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cluster_fast_greedy(network_1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## IGRAPH clustering fast greedy, groups: 3, mod: 0.32
## + groups:
##   $`1`
##    [1] &amp;quot;ind_05&amp;quot; &amp;quot;ind_09&amp;quot; &amp;quot;ind_12&amp;quot; &amp;quot;ind_17&amp;quot; &amp;quot;ind_20&amp;quot; &amp;quot;ind_23&amp;quot; &amp;quot;ind_26&amp;quot; &amp;quot;ind_29&amp;quot;
##    [9] &amp;quot;ind_31&amp;quot; &amp;quot;ind_32&amp;quot; &amp;quot;ind_36&amp;quot; &amp;quot;ind_38&amp;quot; &amp;quot;ind_40&amp;quot; &amp;quot;ind_43&amp;quot; &amp;quot;ind_49&amp;quot; &amp;quot;ind_50&amp;quot;
##   
##   $`2`
##    [1] &amp;quot;ind_03&amp;quot; &amp;quot;ind_15&amp;quot; &amp;quot;ind_19&amp;quot; &amp;quot;ind_21&amp;quot; &amp;quot;ind_22&amp;quot; &amp;quot;ind_27&amp;quot; &amp;quot;ind_28&amp;quot; &amp;quot;ind_37&amp;quot;
##    [9] &amp;quot;ind_39&amp;quot; &amp;quot;ind_45&amp;quot; &amp;quot;ind_46&amp;quot; &amp;quot;ind_47&amp;quot; &amp;quot;ind_48&amp;quot;
##   
##   $`3`
##    [1] &amp;quot;ind_01&amp;quot; &amp;quot;ind_02&amp;quot; &amp;quot;ind_04&amp;quot; &amp;quot;ind_06&amp;quot; &amp;quot;ind_07&amp;quot; &amp;quot;ind_08&amp;quot; &amp;quot;ind_10&amp;quot; &amp;quot;ind_11&amp;quot;
##   + ... omitted several groups/vertices&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, the function tries to detect clusters (called &lt;code&gt;groups&lt;/code&gt;) and assigns each individual to such a group. Furthermore, it calculates modularity (&lt;code&gt;mod&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The aim of this post is to use several of these functions and then compare 1) the number of detected groups and 2) the detected group membership of all individuals to what was simulated (&lt;em&gt;i.e.&lt;/em&gt;, the ‘true’ values). Furthermore, I will extract the global modularity, which can be used to compare the quality of different cluster methods (many of the algorithms try to maximize modularity when searching for clusters).&lt;/p&gt;
&lt;p&gt;Therefore, I first define a function to apply the specified algorithm to a network, extract these metrics from the resulting &lt;code&gt;communities&lt;/code&gt;-object, and return them in a dataframe.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_communities &amp;lt;- function(igraph_network, cluster_method = NULL){
  if(is.null(cluster_method)) { stop(&amp;quot;no method specificied&amp;quot;) }
  community_object &amp;lt;- do.call(cluster_method, list(igraph_network))
  return(tibble(Ind = community_object$names,
                Ind_Cluster = community_object$membership,
                global_modularity = modularity(igraph_network,
                                               community_object$membership,
                                               weights = E(igraph_network)$weight),
                method = cluster_method) %&amp;gt;% 
           arrange(Ind))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_communities(network_1, &amp;quot;cluster_fast_greedy&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 50 x 4
##    Ind    Ind_Cluster global_modularity method             
##    &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;             &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;              
##  1 ind_01           3             0.318 cluster_fast_greedy
##  2 ind_02           3             0.318 cluster_fast_greedy
##  3 ind_03           2             0.318 cluster_fast_greedy
##  4 ind_04           3             0.318 cluster_fast_greedy
##  5 ind_05           1             0.318 cluster_fast_greedy
##  6 ind_06           3             0.318 cluster_fast_greedy
##  7 ind_07           3             0.318 cluster_fast_greedy
##  8 ind_08           3             0.318 cluster_fast_greedy
##  9 ind_09           1             0.318 cluster_fast_greedy
## 10 ind_10           3             0.318 cluster_fast_greedy
## # … with 40 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this function, I apply several of the provided &lt;code&gt;igraph&lt;/code&gt; methods with the four networks.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;networks &amp;lt;- grep(&amp;quot;network_\\d&amp;quot;, ls(), value = T)
cluster_methods &amp;lt;- c(&amp;quot;cluster_fast_greedy&amp;quot;, &amp;quot;cluster_infomap&amp;quot;,
                     &amp;quot;cluster_label_prop&amp;quot;, &amp;quot;cluster_optimal&amp;quot;,
                     &amp;quot;cluster_louvain&amp;quot;, &amp;quot;cluster_walktrap&amp;quot;)

for(network_i in seq_along(networks)){
  for(cluster_method_j in seq_along(cluster_methods)){
    df_temp &amp;lt;- get_communities(igraph_network = get(networks[[network_i]]),
                               cluster_method = cluster_methods[[cluster_method_j]])
    df_temp$network &amp;lt;- networks[[network_i]]
    if(network_i == 1 &amp;amp; cluster_method_j == 1) community_df &amp;lt;- df_temp
    else community_df &amp;lt;- bind_rows(community_df, df_temp)
  }
}

# Show structure of created dataframe
str(community_df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;tbl_df&amp;#39;, &amp;#39;tbl&amp;#39; and &amp;#39;data.frame&amp;#39;:    1200 obs. of  5 variables:
##  $ Ind              : chr  &amp;quot;ind_01&amp;quot; &amp;quot;ind_02&amp;quot; &amp;quot;ind_03&amp;quot; &amp;quot;ind_04&amp;quot; ...
##  $ Ind_Cluster      : num  3 3 2 3 1 3 3 3 1 3 ...
##  $ global_modularity: num  0.318 0.318 0.318 0.318 0.318 ...
##  $ method           : chr  &amp;quot;cluster_fast_greedy&amp;quot; &amp;quot;cluster_fast_greedy&amp;quot; &amp;quot;cluster_fast_greedy&amp;quot; &amp;quot;cluster_fast_greedy&amp;quot; ...
##  $ network          : chr  &amp;quot;network_1&amp;quot; &amp;quot;network_1&amp;quot; &amp;quot;network_1&amp;quot; &amp;quot;network_1&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting table includes the global modularity for each method and network, and the estimated group membership (&lt;code&gt;$Ind_Cluster&lt;/code&gt;) of all individuals within each networks using each of the methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compare-the-detected-clusters-with-simulated-groups&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.4 Compare the detected clusters with simulated groups&lt;/h3&gt;
&lt;p&gt;Finally, I compare the results of the different algorithms with the simulated networks.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Set up dataframe for loop
cluster_summary &amp;lt;- tibble(
  Cluster_method = rep(cluster_methods, each = length(networks)),
  Scenario = rep(networks, times = length(cluster_methods)),
  Dyads_n = length(unique(network_df$dyad)),
  Groups_n = length(unique(network_df$Ind_A_Group)),
  Clusters_n = NA,
  Dyads_correct_n = NA,
  Dyads_correct_prop = NA,
  Modularity = NA)
  
# Use a loop to summarize for all methods and networks the 1) number of clusters
# in comparison to simulated groups, and 2) the number of dyads correctly placed
# together in a cluster.
for(row_i in 1:nrow(cluster_summary)){
  community_temp &amp;lt;- filter(community_df,
                           method == cluster_summary[row_i,]$Cluster_method &amp;amp;
                           network == cluster_summary[row_i,]$Scenario)
  
  cluster_summary_temp &amp;lt;- network_df %&amp;gt;%
    select(Ind_A, Ind_B, Ind_A_Group, Ind_B_Group) %&amp;gt;%
    left_join(select(community_temp, Ind_A = Ind, Ind_A_Cluster = Ind_Cluster),
              by = &amp;quot;Ind_A&amp;quot;) %&amp;gt;%
    left_join(select(community_temp, Ind_B = Ind, Ind_B_Cluster = Ind_Cluster),
              by = &amp;quot;Ind_B&amp;quot;) %&amp;gt;%
    mutate(same_group = (Ind_A_Group == Ind_B_Group),
           same_cluster = (Ind_A_Cluster == Ind_B_Cluster))
  
    cluster_summary[row_i,]$Clusters_n = length(unique(community_temp$Ind_Cluster))
    cluster_summary[row_i,]$Dyads_correct_n = sum(cluster_summary_temp$same_group == cluster_summary_temp$same_cluster)
    cluster_summary[row_i,]$Modularity = unique(community_temp$global_modularity)
}

# Calculate variables comparing simulated with detected clusters and apply some
# other cosmetic changes
cluster_summary &amp;lt;- cluster_summary %&amp;gt;% 
  mutate(Dyads_correct_prop = Dyads_correct_n/Dyads_n,
         Clusters_vs_Groups = Clusters_n/Groups_n,
         Scenario = str_replace(Scenario, &amp;quot;network_&amp;quot;, &amp;quot;S&amp;quot;),
         Cluster_method = str_remove(Cluster_method, &amp;quot;cluster_&amp;quot;)) %&amp;gt;% 
  mutate_if(is.numeric, ~round(., 2))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the resulting table:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;knitr::kable(cluster_summary)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Cluster_method&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Scenario&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dyads_n&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Groups_n&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Clusters_n&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dyads_correct_n&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dyads_correct_prop&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Modularity&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Clusters_vs_Groups&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;fast_greedy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;fast_greedy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;fast_greedy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.31&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;fast_greedy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;infomap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;infomap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;infomap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;infomap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;label_prop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;848&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.69&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;label_prop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;label_prop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.29&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;label_prop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;848&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.69&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;optimal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;optimal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;optimal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.31&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;optimal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;louvain&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;louvain&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;louvain&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.31&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;louvain&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;walktrap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;walktrap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1121&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;walktrap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.31&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;walktrap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;S4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Perhaps, it’s a bit easier to interpret the results when graphically illustrated.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;illustrate-results&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.5 Illustrate results&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;create_plot &amp;lt;- function(df, y_var, y_title){
  y_var &amp;lt;- sym(y_var)
  ggplot(data = df,
            aes(x = Scenario, y = !!y_var, group = Cluster_method, color = Cluster_method)) +
  geom_line(size = 1.25, alpha = .6) +
  geom_point(color = &amp;quot;black&amp;quot;, size = 2, alpha = .5) +
  ggrepel::geom_label_repel(data = filter(df, Scenario == &amp;quot;S4&amp;quot;),
            aes(x = Scenario, y = !!y_var, color = Cluster_method, label = Cluster_method),
            size = 4,
            hjust = 0, nudge_x = .5, direction = &amp;quot;y&amp;quot;,
            label.padding = .1, point.padding = .5, segment.size = .25,
            show.legend = F) +
  scale_x_discrete(limits = c(&amp;quot;S1&amp;quot;, &amp;quot;S2&amp;quot;, &amp;quot;S3&amp;quot;, &amp;quot;S4&amp;quot;, rep(&amp;quot;&amp;quot;, 4))) +
  scale_y_continuous(name = y_title, limits = c(0, NA)) +
  theme_minimal() +
  theme(legend.position = &amp;quot;none&amp;quot;)
}

cluster_plot &amp;lt;- create_plot(df = cluster_summary,
                            y_var = &amp;quot;Clusters_vs_Groups&amp;quot;,
                            y_title = &amp;quot;Detected # Clusters / True # Groups&amp;quot;)
dyad_plot &amp;lt;- create_plot(df = cluster_summary,
                         y_var = &amp;quot;Dyads_correct_prop&amp;quot;,
                         y_title = &amp;quot;Correct # Dyads / Total # Dyads&amp;quot;)
modularity_plot &amp;lt;- create_plot(df = cluster_summary,
                               y_var = &amp;quot;Modularity&amp;quot;,
                               y_title = &amp;quot;Modularity&amp;quot;)

cowplot::plot_grid(cluster_plot, dyad_plot, modularity_plot, ncol = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/social-clusters-II/index_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.6 Conclusions&lt;/h3&gt;
&lt;p&gt;For the created networks, here are my conclusions:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;None(!) of the tested algorithms correctly identified the number of groups in S1 and S2 (the two scenarios with ‘close groups’). But three of the four algorithms that did best in these two scenarios (&lt;em&gt;louvain&lt;/em&gt;, &lt;em&gt;walktrap&lt;/em&gt;, &lt;em&gt;optimal&lt;/em&gt;) perfectly identified groups in S3 and S4. Thus, under the circumstances simulated in S1 and S2, which are fairly common in reality I believe, one should be careful with the interpretation of the number of detected clusters.&lt;/li&gt;
&lt;li&gt;With the exception of S1, the &lt;em&gt;infomap&lt;/em&gt; algorithm did not very well and put all individuals in the same cluster. The &lt;em&gt;label_prob&lt;/em&gt; method was a bit better than &lt;em&gt;infomap&lt;/em&gt;, but always failed to identify the correct number of groups.&lt;/li&gt;
&lt;li&gt;The comparison of modularity values confirms that the algorithms with the highest modularity values also were the best in identifying groups and individual group memberships (note that these modularity values are calculated without knowing the ‘true’ groups).&lt;/li&gt;
&lt;li&gt;As mentioned above and shown in the plot below, the simulation actually created many, fairly weak relationships among individuals, even among individuals from different groups. Perhaps, this makes the detection of clusters challenging for the algorithms, especially if the distinction between different groups within a larger community is variable (as in S1, S2). Thus, when applying such methods to identify clusters, it seems to be important to simulate some networks similar to the observed networks and try which methods are most appropriate given the circumstances.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;identifying-and-illustrating-clusters-with-ggraph&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.7 Identifying and illustrating clusters with &lt;code&gt;ggraph&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ggraph&lt;/code&gt; package also supports the use of the &lt;code&gt;igraph::cluster_&lt;/code&gt; functions, which can be nicely used for a quick look at clusters. Here, both the detected clusters (using different colors) and the simulated groups (using different shapes) are shown. In contrast to the plots above, all relationships (or &lt;em&gt;edges&lt;/em&gt;) are shown, including those &amp;lt; 0.3, which makes the networks look much denser than in the other plots.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;network_df %&amp;gt;% 
  select(from = Ind_A, to = Ind_B, weight = S1) %&amp;gt;% 
  as_tbl_graph(directed = FALSE) %&amp;gt;% 
  activate(nodes) %&amp;gt;% 
  left_join(distinct(individual_df, name = Ind, group = Group),
            by = &amp;quot;name&amp;quot;) %&amp;gt;%
  mutate(detected_cluster = as.factor(group_louvain())) %&amp;gt;% 
  ggraph(., layout = &amp;quot;fr&amp;quot;) +
  geom_edge_arc(aes(width = weight),
                alpha = 0.3, strength = 0.1) +
  scale_edge_width(name = &amp;quot;Association Index&amp;quot;, range = c(0, 1.5)) +
  geom_node_point(aes(fill = detected_cluster, shape = group),
                  color = &amp;quot;black&amp;quot;, size = 4) +
  scale_fill_brewer(type = &amp;quot;qual&amp;quot;, palette = 2) +
  scale_shape_manual(values = c(21, 22, 23, 24)) +
  theme_graph() +
  guides(fill = guide_legend(override.aes = list(shape=21)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/social-clusters-II/index_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s clear from this plot that group_a and group_b are put in the same cluster by the &lt;em&gt;louvain&lt;/em&gt; method.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Creation and Detection of Clusters in Social Networks - Part 1</title>
      <link>https://bedatablog.netlify.com/post/social-clusters-i/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://bedatablog.netlify.com/post/social-clusters-i/</guid>
      <description>


&lt;p&gt;Social networks often exhibit some kind of clustering (or &lt;em&gt;community structure&lt;/em&gt;), such as distinct social groups in animal societies, or kin groups (or families) within social groups. Individuals within such clusters are more likely to interact with each other than individuals from different clusters.&lt;/p&gt;
&lt;p&gt;There are many algorithms to detect clusters in social networks, and one might work better than another under some circumstances (see, e.g., &lt;a href=&#34;https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0159161&#34;&gt;Emmons et al. 2016&lt;/a&gt;). Therefore, the aim of this and the next post is to simulate clustered social networks, and then to apply and compare some of the methods provided by the R-package &lt;code&gt;igraph&lt;/code&gt; with these networks.&lt;/p&gt;
&lt;p&gt;Note that there are functions available for R to create such networks, but here I create these networks ‘from scratch’ for two reasons:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It is easier to understand (and modify) the process underlying the network simulation.&lt;/li&gt;
&lt;li&gt;Some clusters might be ‘closer’ to each other than other clusters. For example, individuals from two close families might be more likely to interact with each other than with individuals from other families. Perhaps, this can be achieved with the available functions, but I preferred to model these different degrees of clustering on my own.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This project will consist of two parts:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Simulate clustered social networks.&lt;/strong&gt; I will simulate values of an ‘association index’ (reflecting social relationships) for dyads of individuals within the same groups, for dyads of individuals from ‘close’ groups, and for dyads consisting of individuals from different groups that are not close to each other. In total, I will simulate four different scenarios with varying degrees of clustering.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Determine clustering using different methods and compare the results.&lt;/strong&gt; I will use several of the methods provided by the &lt;code&gt;igraph&lt;/code&gt; package to detect clusters in these simulated networks. Then, I will calculate and compare the modularity of different networks, the number of detected clusters in comparison to simulated clusters, and the proportion of dyads correctly assigned to the same cluster.&lt;/p&gt;
&lt;div id=&#34;simulate-clustered-social-networks&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1. Simulate clustered social networks&lt;/h1&gt;
&lt;div id=&#34;prepare-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.1 Prepare R&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list = ls())
library(tidyverse)
library(tidygraph)
library(ggraph)
library(igraph)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-a-dataframe-with-identities-and-group-memberships-of-individuals&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.2 Create a dataframe with identities and group memberships of individuals&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Specify number of individuals and groups (or clusters)
n_inds &amp;lt;- 50
n_groups &amp;lt;- 4

# Create IDs for all individuals and assign random social groups to individuals
set.seed(1209)
individual_df &amp;lt;- tibble(
  Ind = paste0(&amp;quot;ind_&amp;quot;, str_pad(1:n_inds, width = nchar(n_inds), pad = &amp;quot;0&amp;quot;)),
  Group = sample(x = paste0(&amp;quot;group_&amp;quot;, letters[1:n_groups]),
                 size = n_inds,
                 replace = T))

# Create a dataframe with all possible combinations of individuals except &amp;#39;self-relationships&amp;#39;
network_df &amp;lt;- expand.grid(Ind_A = individual_df$Ind,
                          Ind_B = individual_df$Ind,
                          stringsAsFactors = F) %&amp;gt;%
  left_join(select(individual_df, Ind_A = Ind, Ind_A_Group = Group),
            by = &amp;quot;Ind_A&amp;quot;) %&amp;gt;% 
  left_join(select(individual_df, Ind_B = Ind, Ind_B_Group = Group),
            by = &amp;quot;Ind_B&amp;quot;) %&amp;gt;% 
  filter(Ind_A != Ind_B)

# Limit the dataframe to one row per dyad for an undirected network
network_df &amp;lt;- network_df %&amp;gt;% 
  arrange(Ind_A, Ind_B) %&amp;gt;% 
  mutate(dyad = if_else(Ind_A &amp;lt; Ind_B, paste0(Ind_A, &amp;quot;_&amp;quot;, Ind_B),
                        paste0(Ind_B, &amp;quot;_&amp;quot;, Ind_A))) %&amp;gt;% 
  distinct(dyad, .keep_all = T)

head(network_df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Ind_A  Ind_B Ind_A_Group Ind_B_Group          dyad
## 1 ind_01 ind_02     group_b     group_a ind_01_ind_02
## 2 ind_01 ind_03     group_b     group_c ind_01_ind_03
## 3 ind_01 ind_04     group_b     group_b ind_01_ind_04
## 4 ind_01 ind_05     group_b     group_d ind_01_ind_05
## 5 ind_01 ind_06     group_b     group_a ind_01_ind_06
## 6 ind_01 ind_07     group_b     group_b ind_01_ind_07&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;assign-values-or-weights-to-all-dyadic-relationships.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.3 Assign values (or ‘weights’) to all dyadic relationships.&lt;/h3&gt;
&lt;p&gt;Here, I use 4 different scenarios:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Scenario (S1):&lt;/strong&gt; Within-group relationships (&lt;em&gt;wgr&lt;/em&gt;) are relatively strong in comparison to between-group relationships (&lt;em&gt;bgr&lt;/em&gt;). Relationships of individuals between ‘close groups’ (&lt;em&gt;bcgr&lt;/em&gt;) are intermediate.&lt;br /&gt;
&lt;strong&gt;2. Scenario (S2):&lt;/strong&gt; Similar to S1, but differences between &lt;em&gt;wgr&lt;/em&gt;, &lt;em&gt;bcgr&lt;/em&gt;, and &lt;em&gt;bgr&lt;/em&gt; are smaller.&lt;br /&gt;
&lt;strong&gt;3. Scenario (S3):&lt;/strong&gt; &lt;em&gt;Wgr&lt;/em&gt; are relatively strong in comparison to &lt;em&gt;bgr&lt;/em&gt;. This scenario is identical to S1 except that there are no close groups.&lt;br /&gt;
&lt;strong&gt;4. Scenario (S4):&lt;/strong&gt; Differences between &lt;em&gt;wgr&lt;/em&gt; and &lt;em&gt;bgr&lt;/em&gt; are smaller than in S3. This scenario is identical to S2 except that there are no close groups.&lt;/p&gt;
&lt;p&gt;Thus, &lt;em&gt;bgr&lt;/em&gt; are the same in all four scenarios, only &lt;em&gt;bcgr&lt;/em&gt; and &lt;em&gt;wgr&lt;/em&gt; are varied. Furthermore, &lt;em&gt;wgr&lt;/em&gt; are the same for S1 and S3, and for S2 and S4 (see plot below).&lt;/p&gt;
&lt;p&gt;To create the social networks, I sample values from beta distributions simulating an &lt;strong&gt;Association Index&lt;/strong&gt;. Such an index is commonly used in animal behavioural research to assess relationships between individuals (see, e.g., the great book by &lt;a href=&#34;https://www.press.uchicago.edu/ucp/books/book/chicago/A/bo5607202.html&#34;&gt;Whitehead, 2008&lt;/a&gt;), and they range from 0 to 1. For example, individuals that never associate with each other would have an association index of 0, and two individuals that are always associated with each other have an index of 1.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Set the parameters (i.e. shape parameters of the beta distribution) for all 4
# scenarios
bgr &amp;lt;- c(1, 8)
bcgr_1 &amp;lt;- c(3, 8)
wgr_1 &amp;lt;- wgr_3 &amp;lt;- c(8, 8)

bcgr_2 &amp;lt;- c(1.5, 8)
wgr_2 &amp;lt;- wgr_4 &amp;lt;- c(4, 8)

# Define function for plotting of beta distributions
plot_beta &amp;lt;- function(x, alpha_beta, main = &amp;quot;&amp;quot;, xlab = &amp;quot;&amp;quot;, ylab = &amp;quot;&amp;quot;, ...){
  alpha = alpha_beta[1]
  beta =  alpha_beta[2]
  plot(x, dbeta(x, alpha, beta), type = &amp;quot;l&amp;quot;,
       yaxt = &amp;quot;n&amp;quot;, xlab = &amp;quot;&amp;quot;, ylab = &amp;quot;&amp;quot;, bty = &amp;quot;n&amp;quot;, ...)
  title(ylab = ylab, line = 0)
  title(xlab = xlab, line = 2)
  title(main = main, line = 1)
  axis(side = 2, label = F, lwd.ticks = F)
}
# Plot the distributions of social relationships according to these parameters
{
  par(mfrow = c(4,3), mar = c(3, 2, 2, 1))
  x &amp;lt;- seq(0, 1, length.out = 40)
  
  # S1
  plot_beta(x, bgr, main = &amp;quot;Between-group - S1&amp;quot;,
            ylab = &amp;quot;Prob. density function&amp;quot;)
  plot_beta(x, bcgr_1, main = &amp;quot;Between close-groups - S1&amp;quot;)
  plot_beta(x, wgr_1, main = &amp;quot;Within-group S1&amp;quot;)
  
  # S2
  plot_beta(x, bgr, main = &amp;quot;Between-group - S2&amp;quot;,
            ylab = &amp;quot;Prob. density function&amp;quot;)
  plot_beta(x, bcgr_2, main = &amp;quot;Between close-groups - S2&amp;quot;,
            xlab = &amp;quot;Association Index&amp;quot;)
  plot_beta(x, wgr_2, main = &amp;quot;Within-group - S2&amp;quot;)
  
  # S3
  plot_beta(x, bgr, main = &amp;quot;Between-group - S3&amp;quot;,
            ylab = &amp;quot;Prob. density function&amp;quot;)
  plot.new()
  plot_beta(x, wgr_3, main = &amp;quot;Within-group - S3&amp;quot;)
  
  # S4
  plot_beta(x, bgr, main = &amp;quot;Between-group - S4&amp;quot;, 
            ylab = &amp;quot;Prob. density function&amp;quot;,
            xlab = &amp;quot;Association Index&amp;quot;)
  plot.new()
  plot_beta(x, wgr_4, main = &amp;quot;Within-group - S4&amp;quot;,
            xlab = &amp;quot;Association Index&amp;quot;)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/social-clusters-I/index_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;These distributions can be used to get values for the strength of relationships. To do so, I first define a function to sample dyadic values from the different distributions depending on group membership of both individuals. Then, I use this function to get values for all dyads and for all scenarios. For S1 and S2, group A and B are defined as the close groups.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_weights &amp;lt;- function(network_df, wgr, bgr, bcgr = NA, close_groups = NA){
  # Create empty vector for all weights
  weights = rep(NA_real_, time = nrow(network_df))
  # Go through all dyads and sample from respective distribution, dependent on
  # the group membership of both individuals
  for(i in seq_along(weights)){
    ind_A_group &amp;lt;- network_df[i, &amp;quot;Ind_A_Group&amp;quot;]
    ind_B_group &amp;lt;- network_df[i, &amp;quot;Ind_B_Group&amp;quot;]
    # Both individuals in same group
    if(ind_A_group == ind_B_group){
      weights[i] &amp;lt;- rbeta(n = 1, shape1 = wgr[1], shape2 = wgr[2])
    }
    # Individuals in different groups
    if(ind_A_group != ind_B_group){
      weights[i] &amp;lt;- rbeta(n = 1, shape1 = bgr[1], shape2 = bgr[2])
    }
    # If some groups are &amp;#39;closer&amp;#39; to each other, use specified distributions for
    # this kind of relationships
    if(all(!is.na(bcgr)) &amp;amp; all(!is.na(close_groups)) &amp;amp;
       ind_A_group != ind_B_group &amp;amp;
       ind_A_group %in% close_groups &amp;amp; 
       ind_B_group %in% close_groups){
      weights[i] &amp;lt;- rbeta(n = 1, shape1 = bcgr[1], shape2 = bcgr[2])
      }
  }
  return(weights)
}

set.seed(1209)
network_df$S1 &amp;lt;- get_weights(network_df, wgr = wgr_1, bgr = bgr, bcgr = bcgr_1,
                             close_groups = c(&amp;quot;group_a&amp;quot;, &amp;quot;group_b&amp;quot;))
network_df$S2 &amp;lt;- get_weights(network_df, wgr = wgr_2, bgr = bgr, bcgr = bcgr_2,
                             close_groups = c(&amp;quot;group_a&amp;quot;, &amp;quot;group_b&amp;quot;))
network_df$S3 &amp;lt;- get_weights(network_df, wgr = wgr_3, bgr = bgr)
network_df$S4 &amp;lt;- get_weights(network_df, wgr = wgr_4, bgr = bgr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the last step for part 1 of this post, I will illustrate the created networks using the &lt;code&gt;ggraph&lt;/code&gt; package (look &lt;a href=&#34;https://www.data-imaginist.com/2019/1-giraffe-2-giraffe-go/&#34;&gt;here&lt;/a&gt; for an introduction to this package by the author)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1209)
clustered_network_plot &amp;lt;- network_df %&amp;gt;% 
  pivot_longer(cols = matches(&amp;quot;S\\d&amp;quot;),
               names_to = &amp;quot;Scenario&amp;quot;,
               values_to = &amp;quot;weight&amp;quot;) %&amp;gt;% 
  select(from = Ind_A, to = Ind_B, weight, Scenario) %&amp;gt;% 
  filter(weight &amp;gt;= 0.3) %&amp;gt;% 
  as_tbl_graph() %&amp;gt;% 
  activate(nodes) %&amp;gt;% 
  left_join(distinct(individual_df, name = Ind, group = Group),
            by = &amp;quot;name&amp;quot;) %&amp;gt;% 
  ggraph(., layout = &amp;quot;fr&amp;quot;) +
  geom_edge_arc(aes(width = weight),
                alpha = 0.4, strength = 0.1) +
  scale_edge_width(name = &amp;quot;Association Index&amp;quot;,
                   range = c(0.2, 1)) +
  geom_node_point(aes(fill = group, shape = group),
                  size = 2) +
  scale_fill_brewer(type = &amp;quot;qual&amp;quot;, palette = 2) +
  scale_shape_manual(values = c(21, 22, 23, 24)) +
  facet_edges(~Scenario) +
  theme_graph()

clustered_network_plot&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://bedatablog.netlify.com/post/social-clusters-I/index_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;
As modeled above, S1 and S3 are very similar, except that group A and B are closer to each other in S1. S2 and S4 have both weaker within-group relationships compared to their counterparts S1 and S3, respectively. Thus, I have four different networks with different degrees of clustering, and in two of these networks, two of the four groups are closer to each other than to the other groups.&lt;/p&gt;
&lt;p&gt;In the next post, I will use different algorithms from the &lt;code&gt;igraph&lt;/code&gt; package to check how well these clusters can be detected.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
