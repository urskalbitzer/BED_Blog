[{"authors":["admin"],"categories":null,"content":"For my research, I analyze behavioural, ecological, geographic, socio-economic and other types of data. Usually, the first steps are to figure out how and from where to get the data (if they are publicly available), to do some first cleaning and pre-processing, and then to test potential methods to obtain insights from the data.\nSince I very often benefit from other blogs while working with data, and because I am absolutely fascinated about all the possibilities that arise from public data and open source tools, my aim for this blog is to share some of my data projects. My hope is that other people benefit from this blog just as I benefit from all the great resources made available by other people.\nFor more information about my research, please look at my webpage.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"For my research, I analyze behavioural, ecological, geographic, socio-economic and other types of data. Usually, the first steps are to figure out how and from where to get the data (if they are publicly available), to do some first cleaning and pre-processing, and then to test potential methods to obtain insights from the data.\nSince I very often benefit from other blogs while working with data, and because I am absolutely fascinated about all the possibilities that arise from public data and open source tools, my aim for this blog is to share some of my data projects.","tags":null,"title":"Urs Kalbitzer","type":"authors"},{"authors":[],"categories":[],"content":" Social networks often exhibit some kind of clustering (or community structure), such as distinct social groups in animal societies, or kin groups (or families) within social groups. Individuals within such clusters are more likely to interact with each other than individuals from different clusters.\nThere are many algorithms to detect clusters in social networks, and one might work better than another under some circumstances (see, e.g., Emmons et al. 2016). Therefore, the aim of this and the next post is to simulate clustered social networks, and then to apply and compare some of the methods provided by the R-package igraph with these networks.\nNote that there are functions available for R to create such networks, but here I create these networks ‘from scratch’ for two reasons:\nIt is easier to understand (and modify) the process underlying the network simulation. Some clusters might be ‘closer’ to each other than other clusters. For example, individuals from two close families might be more likely to interact with each other than with individuals from other families. Perhaps, this can be achieved with the available functions, but I preferred to model these different degrees of clustering on my own.  This project will consist of two parts:\n1. Simulate clustered social networks. I will simulate values of an ‘association index’ (reflecting social relationships) for dyads of individuals within the same groups, for dyads of individuals from ‘close’ groups, and for dyads consisting of individuals from different groups that are not close to each other. In total, I will simulate four different scenarios with varying degrees of clustering.\n2. Determine clustering using different methods and compare the results. I will use several of the methods provided by the igraph package to detect clusters in these simulated networks. Then, I will calculate and compare the modularity of different networks, the number of detected clusters in comparison to simulated clusters, and the proportion of dyads correctly assigned to the same cluster.\n1. Simulate clustered social networks 1.1 Prepare R rm(list = ls()) library(tidyverse) library(tidygraph) library(ggraph) library(igraph)  1.2 Create a dataframe with identities and group memberships of individuals # Specify number of individuals and groups (or clusters) n_inds \u0026lt;- 50 n_groups \u0026lt;- 4 # Create IDs for all individuals and assign random social groups to individuals set.seed(1209) individual_df \u0026lt;- tibble( Ind = paste0(\u0026quot;ind_\u0026quot;, str_pad(1:n_inds, width = nchar(n_inds), pad = \u0026quot;0\u0026quot;)), Group = sample(x = paste0(\u0026quot;group_\u0026quot;, letters[1:n_groups]), size = n_inds, replace = T)) # Create a dataframe with all possible combinations of individuals except \u0026#39;self-relationships\u0026#39; network_df \u0026lt;- expand.grid(Ind_A = individual_df$Ind, Ind_B = individual_df$Ind, stringsAsFactors = F) %\u0026gt;% left_join(select(individual_df, Ind_A = Ind, Ind_A_Group = Group), by = \u0026quot;Ind_A\u0026quot;) %\u0026gt;% left_join(select(individual_df, Ind_B = Ind, Ind_B_Group = Group), by = \u0026quot;Ind_B\u0026quot;) %\u0026gt;% filter(Ind_A != Ind_B) # Limit the dataframe to one row per dyad for an undirected network network_df \u0026lt;- network_df %\u0026gt;% arrange(Ind_A, Ind_B) %\u0026gt;% mutate(dyad = if_else(Ind_A \u0026lt; Ind_B, paste0(Ind_A, \u0026quot;_\u0026quot;, Ind_B), paste0(Ind_B, \u0026quot;_\u0026quot;, Ind_A))) %\u0026gt;% distinct(dyad, .keep_all = T) head(network_df) ## Ind_A Ind_B Ind_A_Group Ind_B_Group dyad ## 1 ind_01 ind_02 group_b group_a ind_01_ind_02 ## 2 ind_01 ind_03 group_b group_c ind_01_ind_03 ## 3 ind_01 ind_04 group_b group_b ind_01_ind_04 ## 4 ind_01 ind_05 group_b group_d ind_01_ind_05 ## 5 ind_01 ind_06 group_b group_a ind_01_ind_06 ## 6 ind_01 ind_07 group_b group_b ind_01_ind_07  1.3 Assign values (or ‘weights’) to all dyadic relationships. Here, I use 4 different scenarios:\n1. Scenario (S1): Within-group relationships (wgr) are relatively strong in comparison to between-group relationships (bgr). Relationships of individuals between ‘close groups’ (bcgr) are intermediate.\n2. Scenario (S2): Similar to S1, but differences between wgr, bcgr, and bgr are smaller.\n3. Scenario (S3): Wgr are relatively strong in comparison to bgr. This scenario is identical to S1 except that there are no close groups.\n4. Scenario (S4): Differences between wgr and bgr are smaller than in S3. This scenario is identical to S2 except that there are no close groups.\nThus, bgr are the same in all four scenarios, only bcgr and wgr are varied. Furthermore, wgr are the same for S1 and S3, and for S2 and S4 (see plot below).\nTo create the social networks, I sample values from beta distributions simulating an Association Index. Such an index is commonly used in animal behavioural research to assess relationships between individuals (see, e.g., the great book by Whitehead, 2008), and they range from 0 to 1. For example, individuals that never associate with each other would have an association index of 0, and two individuals that are always associated with each other have an index of 1.\n# Set the parameters (i.e. shape parameters of the beta distribution) for all 4 # scenarios bgr \u0026lt;- c(1, 8) bcgr_1 \u0026lt;- c(3, 8) wgr_1 \u0026lt;- wgr_3 \u0026lt;- c(8, 8) bcgr_2 \u0026lt;- c(1.5, 8) wgr_2 \u0026lt;- wgr_4 \u0026lt;- c(4, 8) # Define function for plotting of beta distributions plot_beta \u0026lt;- function(x, alpha_beta, main = \u0026quot;\u0026quot;, xlab = \u0026quot;\u0026quot;, ylab = \u0026quot;\u0026quot;, ...){ alpha = alpha_beta[1] beta = alpha_beta[2] plot(x, dbeta(x, alpha, beta), type = \u0026quot;l\u0026quot;, yaxt = \u0026quot;n\u0026quot;, xlab = \u0026quot;\u0026quot;, ylab = \u0026quot;\u0026quot;, bty = \u0026quot;n\u0026quot;, ...) title(ylab = ylab, line = 0) title(xlab = xlab, line = 2) title(main = main, line = 1) axis(side = 2, label = F, lwd.ticks = F) } # Plot the distributions of social relationships according to these parameters { par(mfrow = c(4,3), mar = c(3, 2, 2, 1)) x \u0026lt;- seq(0, 1, length.out = 40) # S1 plot_beta(x, bgr, main = \u0026quot;Between-group - S1\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;) plot_beta(x, bcgr_1, main = \u0026quot;Between close-groups - S1\u0026quot;) plot_beta(x, wgr_1, main = \u0026quot;Within-group S1\u0026quot;) # S2 plot_beta(x, bgr, main = \u0026quot;Between-group - S2\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;) plot_beta(x, bcgr_2, main = \u0026quot;Between close-groups - S2\u0026quot;, xlab = \u0026quot;Association Index\u0026quot;) plot_beta(x, wgr_2, main = \u0026quot;Within-group - S2\u0026quot;) # S3 plot_beta(x, bgr, main = \u0026quot;Between-group - S3\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;) plot.new() plot_beta(x, wgr_3, main = \u0026quot;Within-group - S3\u0026quot;) # S4 plot_beta(x, bgr, main = \u0026quot;Between-group - S4\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;, xlab = \u0026quot;Association Index\u0026quot;) plot.new() plot_beta(x, wgr_4, main = \u0026quot;Within-group - S4\u0026quot;, xlab = \u0026quot;Association Index\u0026quot;) } These distributions can be used to get values for the strength of relationships. To do so, I first define a function to sample dyadic values from the different distributions depending on group membership of both individuals. Then, I use this function to get values for all dyads and for all scenarios. For S1 and S2, group A and B are defined as the close groups.\nget_weights \u0026lt;- function(network_df, wgr, bgr, bcgr = NA, close_groups = NA){ # Create empty vector for all weights weights = rep(NA_real_, time = nrow(network_df)) # Go through all dyads and sample from respective distribution, dependent on # the group membership of both individuals for(i in seq_along(weights)){ ind_A_group \u0026lt;- network_df[i, \u0026quot;Ind_A_Group\u0026quot;] ind_B_group \u0026lt;- network_df[i, \u0026quot;Ind_B_Group\u0026quot;] # Both individuals in same group if(ind_A_group == ind_B_group){ weights[i] \u0026lt;- rbeta(n = 1, shape1 = wgr[1], shape2 = wgr[2]) } # Individuals in different groups if(ind_A_group != ind_B_group){ weights[i] \u0026lt;- rbeta(n = 1, shape1 = bgr[1], shape2 = bgr[2]) } # If some groups are \u0026#39;closer\u0026#39; to each other, use specified distributions for # this kind of relationships if(all(!is.na(bcgr)) \u0026amp; all(!is.na(close_groups)) \u0026amp; ind_A_group != ind_B_group \u0026amp; ind_A_group %in% close_groups \u0026amp; ind_B_group %in% close_groups){ weights[i] \u0026lt;- rbeta(n = 1, shape1 = bcgr[1], shape2 = bcgr[2]) } } return(weights) } set.seed(1209) network_df$S1 \u0026lt;- get_weights(network_df, wgr = wgr_1, bgr = bgr, bcgr = bcgr_1, close_groups = c(\u0026quot;group_a\u0026quot;, \u0026quot;group_b\u0026quot;)) network_df$S2 \u0026lt;- get_weights(network_df, wgr = wgr_2, bgr = bgr, bcgr = bcgr_2, close_groups = c(\u0026quot;group_a\u0026quot;, \u0026quot;group_b\u0026quot;)) network_df$S3 \u0026lt;- get_weights(network_df, wgr = wgr_3, bgr = bgr) network_df$S4 \u0026lt;- get_weights(network_df, wgr = wgr_4, bgr = bgr) As the last step for part 1 of this post, I will illustrate the created networks using the ggraph package (look here for an introduction to this package by the author)\nset.seed(1209) clustered_network_plot \u0026lt;- network_df %\u0026gt;% pivot_longer(cols = matches(\u0026quot;S\\\\d\u0026quot;), names_to = \u0026quot;Scenario\u0026quot;, values_to = \u0026quot;weight\u0026quot;) %\u0026gt;% select(from = Ind_A, to = Ind_B, weight, Scenario) %\u0026gt;% filter(weight \u0026gt;= 0.3) %\u0026gt;% as_tbl_graph() %\u0026gt;% activate(nodes) %\u0026gt;% left_join(distinct(individual_df, name = Ind, group = Group), by = \u0026quot;name\u0026quot;) %\u0026gt;% ggraph(., layout = \u0026quot;fr\u0026quot;) + geom_edge_arc(aes(width = weight), alpha = 0.4, strength = 0.1) + scale_edge_width(name = \u0026quot;Association Index\u0026quot;, range = c(0.2, 1)) + geom_node_point(aes(fill = group, shape = group), size = 2) + scale_fill_brewer(type = \u0026quot;qual\u0026quot;, palette = 2) + scale_shape_manual(values = c(21, 22, 23, 24)) + facet_edges(~Scenario) + theme_graph() clustered_network_plot As modeled above, S1 and S3 are very similar, except that group A and B are closer to each other in S1. S2 and S4 have both weaker within-group relationships compared to their counterparts S1 and S3, respectively. Thus, I have four different networks with different degrees of clustering, and in two of these networks, two of the four groups are closer to each other than to the other groups.\nIn the next post, I will use different algorithms from the igraph package to check how well these clusters can be detected.\n  ","date":1577750400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578053796,"objectID":"52aa7018da711b5dd11bd4bd8a90bce8","permalink":"/post/social-clusters-i/","publishdate":"2019-12-31T00:00:00Z","relpermalink":"/post/social-clusters-i/","section":"post","summary":"Social networks often exhibit some kind of clustering (or community structure), such as distinct social groups in animal societies, or kin groups (or families) within social groups. Individuals within such clusters are more likely to interact with each other than individuals from different clusters.\nThere are many algorithms to detect clusters in social networks, and one might work better than another under some circumstances (see, e.g., Emmons et al. 2016).","tags":["R","Social Networks","igraph","ggraph"],"title":"Creation and Detection of Clusters in Social Networks - Part 1","type":"post"}]