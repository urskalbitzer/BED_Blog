[{"authors":["admin"],"categories":null,"content":"For my research, I analyze behavioural, ecological, geographic, socio-economic and other types of data. Usually, the first steps are to figure out how and from where to get the data (if they are publicly available), to do some first cleaning and pre-processing, and then to test potential methods to obtain insights from the data.\nSince I very often benefit from other blogs while working with data, and because I am absolutely fascinated about all the possibilities that arise from public data and open source tools, my aim for this blog is to share some of my data projects. My hope is that other people benefit from this blog just as I benefit from all the great resources made available by other people.\nFor more information about my research, please look at my webpage.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"For my research, I analyze behavioural, ecological, geographic, socio-economic and other types of data. Usually, the first steps are to figure out how and from where to get the data (if they are publicly available), to do some first cleaning and pre-processing, and then to test potential methods to obtain insights from the data.\nSince I very often benefit from other blogs while working with data, and because I am absolutely fascinated about all the possibilities that arise from public data and open source tools, my aim for this blog is to share some of my data projects.","tags":null,"title":"Urs Kalbitzer","type":"authors"},{"authors":[],"categories":[],"content":" In the previous post, I simulated clustered networks with varying strength of within-group, between-close-groups, and between-group social relationships. In part 2, I am using some of the methods provided by the igraph package to test how well these simulated clusters can be (re)-detected.\n2. Determine clustering using different methods and compare the results 2.1 Prepare R rm(list = ls()) library(tidyverse) library(tidygraph) library(ggraph) library(igraph) In addition to these packages, this notebook requires the installation of the following packages: DT, cowplot, ggrepel.\n 2.2 Recreate the network from previous post To avoid repetition, the code is not shown here, but can be copied from the previous post. The two objects that are required from there are individual_df and network_df.\nThe networks looked like that:\nOne important note: My motivation for this small project was my research on a group of ~50 adult red colobus monkeys. Therefore, I simulated networks where most individuals were somehow connected. The plot above, however, only shows association indices \\(\\ge\\) 0.3 to make it easier to see the clusters. The complete network is much denser (see the final plot of this post). After finalizing the draft of this post, I realized that this may have affected how well (or not) the algorithms detected the (sub)-groups and therefore wanted to mention it here.\n 2.3 Use different algorithms to detect clusters The igraph-package provides several functions to detect communities within a network, which start with cluster_ (type ?communities in R for a complete list). Most of these algorithms are explained here and here.\nBefore using the cluster_ functions, the networks have to be transformed into igraph objects.\ndf_to_network \u0026lt;- function(network_df, weight_col){ network \u0026lt;- graph_from_data_frame(select(network_df, from = Ind_A, to = Ind_B, weight = matches(weight_col)), directed = FALSE) return(network) } network_1 \u0026lt;- df_to_network(network_df, weight_col = \u0026quot;S1\u0026quot;) network_2 \u0026lt;- df_to_network(network_df, weight_col = \u0026quot;S2\u0026quot;) network_3 \u0026lt;- df_to_network(network_df, weight_col = \u0026quot;S3\u0026quot;) network_4 \u0026lt;- df_to_network(network_df, weight_col = \u0026quot;S4\u0026quot;) Here’s the standard output for such an object:\nnetwork_1 ## IGRAPH 9f7d641 UNW- 50 1225 -- ## + attr: name (v/c), weight (e/n) ## + edges from 9f7d641 (vertex names): ## [1] ind_01--ind_02 ind_01--ind_03 ind_01--ind_04 ind_01--ind_05 ind_01--ind_06 ## [6] ind_01--ind_07 ind_01--ind_08 ind_01--ind_09 ind_01--ind_10 ind_01--ind_11 ## [11] ind_01--ind_12 ind_01--ind_13 ind_01--ind_14 ind_01--ind_15 ind_01--ind_16 ## [16] ind_01--ind_17 ind_01--ind_18 ind_01--ind_19 ind_01--ind_20 ind_01--ind_21 ## [21] ind_01--ind_22 ind_01--ind_23 ind_01--ind_24 ind_01--ind_25 ind_01--ind_26 ## [26] ind_01--ind_27 ind_01--ind_28 ind_01--ind_29 ind_01--ind_30 ind_01--ind_31 ## [31] ind_01--ind_32 ind_01--ind_33 ind_01--ind_34 ind_01--ind_35 ind_01--ind_36 ## [36] ind_01--ind_37 ind_01--ind_38 ind_01--ind_39 ind_01--ind_40 ind_01--ind_41 ## + ... omitted several edges And here’s the output if one of the cluster_ functions is applied to a network, in this example the fast-greedy algorithm to the first network (S1):\ncluster_fast_greedy(network_1) ## IGRAPH clustering fast greedy, groups: 3, mod: 0.32 ## + groups: ## $`1` ## [1] \u0026quot;ind_05\u0026quot; \u0026quot;ind_09\u0026quot; \u0026quot;ind_12\u0026quot; \u0026quot;ind_17\u0026quot; \u0026quot;ind_20\u0026quot; \u0026quot;ind_23\u0026quot; \u0026quot;ind_26\u0026quot; \u0026quot;ind_29\u0026quot; ## [9] \u0026quot;ind_31\u0026quot; \u0026quot;ind_32\u0026quot; \u0026quot;ind_36\u0026quot; \u0026quot;ind_38\u0026quot; \u0026quot;ind_40\u0026quot; \u0026quot;ind_43\u0026quot; \u0026quot;ind_49\u0026quot; \u0026quot;ind_50\u0026quot; ## ## $`2` ## [1] \u0026quot;ind_03\u0026quot; \u0026quot;ind_15\u0026quot; \u0026quot;ind_19\u0026quot; \u0026quot;ind_21\u0026quot; \u0026quot;ind_22\u0026quot; \u0026quot;ind_27\u0026quot; \u0026quot;ind_28\u0026quot; \u0026quot;ind_37\u0026quot; ## [9] \u0026quot;ind_39\u0026quot; \u0026quot;ind_45\u0026quot; \u0026quot;ind_46\u0026quot; \u0026quot;ind_47\u0026quot; \u0026quot;ind_48\u0026quot; ## ## $`3` ## [1] \u0026quot;ind_01\u0026quot; \u0026quot;ind_02\u0026quot; \u0026quot;ind_04\u0026quot; \u0026quot;ind_06\u0026quot; \u0026quot;ind_07\u0026quot; \u0026quot;ind_08\u0026quot; \u0026quot;ind_10\u0026quot; \u0026quot;ind_11\u0026quot; ## + ... omitted several groups/vertices Thus, the function tries to detect clusters (called groups) and assigns each individual to such a group. Furthermore, it calculates modularity (mod).\nThe aim of this post is to use several of these functions and then compare 1) the number of detected groups and 2) the detected group membership of all individuals to what was simulated (i.e., the ‘true’ values). Furthermore, I will extract the global modularity, which can be used to compare the quality of different cluster methods (many of the algorithms try to maximize modularity when searching for clusters).\nTherefore, I first define a function to apply the specified algorithm to a network, extract these metrics from the resulting communities-object, and return them in a dataframe.\nget_communities \u0026lt;- function(igraph_network, cluster_method = NULL){ if(is.null(cluster_method)) { stop(\u0026quot;no method specificied\u0026quot;) } community_object \u0026lt;- do.call(cluster_method, list(igraph_network)) return(tibble(Ind = community_object$names, Ind_Cluster = community_object$membership, global_modularity = modularity(igraph_network, community_object$membership, weights = E(igraph_network)$weight), method = cluster_method) %\u0026gt;% arrange(Ind)) } Example:\nget_communities(network_1, \u0026quot;cluster_fast_greedy\u0026quot;) ## # A tibble: 50 x 4 ## Ind Ind_Cluster global_modularity method ## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 ind_01 3 0.318 cluster_fast_greedy ## 2 ind_02 3 0.318 cluster_fast_greedy ## 3 ind_03 2 0.318 cluster_fast_greedy ## 4 ind_04 3 0.318 cluster_fast_greedy ## 5 ind_05 1 0.318 cluster_fast_greedy ## 6 ind_06 3 0.318 cluster_fast_greedy ## 7 ind_07 3 0.318 cluster_fast_greedy ## 8 ind_08 3 0.318 cluster_fast_greedy ## 9 ind_09 1 0.318 cluster_fast_greedy ## 10 ind_10 3 0.318 cluster_fast_greedy ## # … with 40 more rows Using this function, I apply several of the provided igraph methods with the four networks.\nnetworks \u0026lt;- grep(\u0026quot;network_\\\\d\u0026quot;, ls(), value = T) cluster_methods \u0026lt;- c(\u0026quot;cluster_fast_greedy\u0026quot;, \u0026quot;cluster_infomap\u0026quot;, \u0026quot;cluster_label_prop\u0026quot;, \u0026quot;cluster_optimal\u0026quot;, \u0026quot;cluster_louvain\u0026quot;, \u0026quot;cluster_walktrap\u0026quot;) for(network_i in seq_along(networks)){ for(cluster_method_j in seq_along(cluster_methods)){ df_temp \u0026lt;- get_communities(igraph_network = get(networks[[network_i]]), cluster_method = cluster_methods[[cluster_method_j]]) df_temp$network \u0026lt;- networks[[network_i]] if(network_i == 1 \u0026amp; cluster_method_j == 1) community_df \u0026lt;- df_temp else community_df \u0026lt;- bind_rows(community_df, df_temp) } } # Show structure of created dataframe str(community_df) ## Classes \u0026#39;tbl_df\u0026#39;, \u0026#39;tbl\u0026#39; and \u0026#39;data.frame\u0026#39;: 1200 obs. of 5 variables: ## $ Ind : chr \u0026quot;ind_01\u0026quot; \u0026quot;ind_02\u0026quot; \u0026quot;ind_03\u0026quot; \u0026quot;ind_04\u0026quot; ... ## $ Ind_Cluster : num 3 3 2 3 1 3 3 3 1 3 ... ## $ global_modularity: num 0.318 0.318 0.318 0.318 0.318 ... ## $ method : chr \u0026quot;cluster_fast_greedy\u0026quot; \u0026quot;cluster_fast_greedy\u0026quot; \u0026quot;cluster_fast_greedy\u0026quot; \u0026quot;cluster_fast_greedy\u0026quot; ... ## $ network : chr \u0026quot;network_1\u0026quot; \u0026quot;network_1\u0026quot; \u0026quot;network_1\u0026quot; \u0026quot;network_1\u0026quot; ... The resulting table includes the global modularity for each method and network, and the estimated group membership ($Ind_Cluster) of all individuals within each networks using each of the methods.\n 2.4 Compare the detected clusters with simulated groups Finally, I compare the results of the different algorithms with the simulated networks.\n# Set up dataframe for loop cluster_summary \u0026lt;- tibble( Cluster_method = rep(cluster_methods, each = length(networks)), Scenario = rep(networks, times = length(cluster_methods)), Dyads_n = length(unique(network_df$dyad)), Groups_n = length(unique(network_df$Ind_A_Group)), Clusters_n = NA, Dyads_correct_n = NA, Dyads_correct_prop = NA, Modularity = NA) # Use a loop to summarize for all methods and networks the 1) number of clusters # in comparison to simulated groups, and 2) the number of dyads correctly placed # together in a cluster. for(row_i in 1:nrow(cluster_summary)){ community_temp \u0026lt;- filter(community_df, method == cluster_summary[row_i,]$Cluster_method \u0026amp; network == cluster_summary[row_i,]$Scenario) cluster_summary_temp \u0026lt;- network_df %\u0026gt;% select(Ind_A, Ind_B, Ind_A_Group, Ind_B_Group) %\u0026gt;% left_join(select(community_temp, Ind_A = Ind, Ind_A_Cluster = Ind_Cluster), by = \u0026quot;Ind_A\u0026quot;) %\u0026gt;% left_join(select(community_temp, Ind_B = Ind, Ind_B_Cluster = Ind_Cluster), by = \u0026quot;Ind_B\u0026quot;) %\u0026gt;% mutate(same_group = (Ind_A_Group == Ind_B_Group), same_cluster = (Ind_A_Cluster == Ind_B_Cluster)) cluster_summary[row_i,]$Clusters_n = length(unique(community_temp$Ind_Cluster)) cluster_summary[row_i,]$Dyads_correct_n = sum(cluster_summary_temp$same_group == cluster_summary_temp$same_cluster) cluster_summary[row_i,]$Modularity = unique(community_temp$global_modularity) } # Calculate variables comparing simulated with detected clusters and apply some # other cosmetic changes cluster_summary \u0026lt;- cluster_summary %\u0026gt;% mutate(Dyads_correct_prop = Dyads_correct_n/Dyads_n, Clusters_vs_Groups = Clusters_n/Groups_n, Scenario = str_replace(Scenario, \u0026quot;network_\u0026quot;, \u0026quot;S\u0026quot;), Cluster_method = str_remove(Cluster_method, \u0026quot;cluster_\u0026quot;)) %\u0026gt;% mutate_if(is.numeric, ~round(., 2)) This is the resulting table:\nknitr::kable(cluster_summary)   Cluster_method Scenario Dyads_n Groups_n Clusters_n Dyads_correct_n Dyads_correct_prop Modularity Clusters_vs_Groups    fast_greedy S1 1225 4 3 1121 0.92 0.32 0.75  fast_greedy S2 1225 4 3 1121 0.92 0.22 0.75  fast_greedy S3 1225 4 4 1225 1.00 0.31 1.00  fast_greedy S4 1225 4 3 1121 0.92 0.22 0.75  infomap S1 1225 4 3 1121 0.92 0.32 0.75  infomap S2 1225 4 1 304 0.25 0.00 0.25  infomap S3 1225 4 1 304 0.25 0.00 0.25  infomap S4 1225 4 1 304 0.25 0.00 0.25  label_prop S1 1225 4 2 848 0.69 0.23 0.50  label_prop S2 1225 4 1 304 0.25 0.00 0.25  label_prop S3 1225 4 3 1121 0.92 0.29 0.75  label_prop S4 1225 4 2 848 0.69 0.17 0.50  optimal S1 1225 4 3 1121 0.92 0.32 0.75  optimal S2 1225 4 3 1121 0.92 0.22 0.75  optimal S3 1225 4 4 1225 1.00 0.31 1.00  optimal S4 1225 4 4 1225 1.00 0.23 1.00  louvain S1 1225 4 3 1121 0.92 0.32 0.75  louvain S2 1225 4 3 1121 0.92 0.22 0.75  louvain S3 1225 4 4 1225 1.00 0.31 1.00  louvain S4 1225 4 4 1225 1.00 0.23 1.00  walktrap S1 1225 4 3 1121 0.92 0.32 0.75  walktrap S2 1225 4 3 1121 0.92 0.22 0.75  walktrap S3 1225 4 4 1225 1.00 0.31 1.00  walktrap S4 1225 4 4 1225 1.00 0.23 1.00    Perhaps, it’s a bit easier to interpret the results when graphically illustrated.\n 2.5 Illustrate results create_plot \u0026lt;- function(df, y_var, y_title){ y_var \u0026lt;- sym(y_var) ggplot(data = df, aes(x = Scenario, y = !!y_var, group = Cluster_method, color = Cluster_method)) + geom_line(size = 1.25, alpha = .6) + geom_point(color = \u0026quot;black\u0026quot;, size = 2, alpha = .5) + ggrepel::geom_label_repel(data = filter(df, Scenario == \u0026quot;S4\u0026quot;), aes(x = Scenario, y = !!y_var, color = Cluster_method, label = Cluster_method), size = 4, hjust = 0, nudge_x = .5, direction = \u0026quot;y\u0026quot;, label.padding = .1, point.padding = .5, segment.size = .25, show.legend = F) + scale_x_discrete(limits = c(\u0026quot;S1\u0026quot;, \u0026quot;S2\u0026quot;, \u0026quot;S3\u0026quot;, \u0026quot;S4\u0026quot;, rep(\u0026quot;\u0026quot;, 4))) + scale_y_continuous(name = y_title, limits = c(0, NA)) + theme_minimal() + theme(legend.position = \u0026quot;none\u0026quot;) } cluster_plot \u0026lt;- create_plot(df = cluster_summary, y_var = \u0026quot;Clusters_vs_Groups\u0026quot;, y_title = \u0026quot;Detected # Clusters / True # Groups\u0026quot;) dyad_plot \u0026lt;- create_plot(df = cluster_summary, y_var = \u0026quot;Dyads_correct_prop\u0026quot;, y_title = \u0026quot;Correct # Dyads / Total # Dyads\u0026quot;) modularity_plot \u0026lt;- create_plot(df = cluster_summary, y_var = \u0026quot;Modularity\u0026quot;, y_title = \u0026quot;Modularity\u0026quot;) cowplot::plot_grid(cluster_plot, dyad_plot, modularity_plot, ncol = 3)  2.6 Conclusions For the created networks, here are my conclusions:\nNone(!) of the tested algorithms correctly identified the number of groups in S1 and S2 (the two scenarios with ‘close groups’). But three of the four algorithms that did best in these two scenarios (louvain, walktrap, optimal) perfectly identified groups in S3 and S4. Thus, under the circumstances simulated in S1 and S2, which are fairly common in reality I believe, one should be careful with the interpretation of the number of detected clusters. With the exception of S1, the infomap algorithm did not very well and put all individuals in the same cluster. The label_prob method was a bit better than infomap, but always failed to identify the correct number of groups. The comparison of modularity values confirms that the algorithms with the highest modularity values also were the best in identifying groups and individual group memberships (note that these modularity values are calculated without knowing the ‘true’ groups). As mentioned above and shown in the plot below, the simulation actually created many, fairly weak relationships among individuals, even among individuals from different groups. Perhaps, this makes the detection of clusters challenging for the algorithms, especially if the distinction between different groups within a larger community is variable (as in S1, S2). Thus, when applying such methods to identify clusters, it seems to be important to simulate some networks similar to the observed networks and try which methods are most appropriate given the circumstances.   2.7 Identifying and illustrating clusters with ggraph The ggraph package also supports the use of the igraph::cluster_ functions, which can be nicely used for a quick look at clusters. Here, both the detected clusters (using different colors) and the simulated groups (using different shapes) are shown. In contrast to the plots above, all relationships (or edges) are shown, including those \u0026lt; 0.3, which makes the networks look much denser than in the other plots.\nnetwork_df %\u0026gt;% select(from = Ind_A, to = Ind_B, weight = S1) %\u0026gt;% as_tbl_graph(directed = FALSE) %\u0026gt;% activate(nodes) %\u0026gt;% left_join(distinct(individual_df, name = Ind, group = Group), by = \u0026quot;name\u0026quot;) %\u0026gt;% mutate(detected_cluster = as.factor(group_louvain())) %\u0026gt;% ggraph(., layout = \u0026quot;fr\u0026quot;) + geom_edge_arc(aes(width = weight), alpha = 0.3, strength = 0.1) + scale_edge_width(name = \u0026quot;Association Index\u0026quot;, range = c(0, 1.5)) + geom_node_point(aes(fill = detected_cluster, shape = group), color = \u0026quot;black\u0026quot;, size = 4) + scale_fill_brewer(type = \u0026quot;qual\u0026quot;, palette = 2) + scale_shape_manual(values = c(21, 22, 23, 24)) + theme_graph() + guides(fill = guide_legend(override.aes = list(shape=21))) It’s clear from this plot that group_a and group_b are put in the same cluster by the louvain method.\n  ","date":1578182400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578254400,"objectID":"5809ad655c73d60698cad0797dd6737b","permalink":"/content/post/social-clusters-ii/","publishdate":"2020-01-05T00:00:00Z","relpermalink":"/content/post/social-clusters-ii/","section":"post","summary":"In the previous post, I simulated clustered networks with varying strength of within-group, between-close-groups, and between-group social relationships. In part 2, I am using some of the methods provided by the igraph package to test how well these simulated clusters can be (re)-detected.\n2. Determine clustering using different methods and compare the results 2.1 Prepare R rm(list = ls()) library(tidyverse) library(tidygraph) library(ggraph) library(igraph) In addition to these packages, this notebook requires the installation of the following packages: DT, cowplot, ggrepel.","tags":["R","Social Networks","ggraph","igraph"],"title":"Creation and Detection of Clusters in Social Networks - Part 2","type":"post"},{"authors":[],"categories":[],"content":" Social networks often exhibit some kind of clustering (or community structure), such as distinct social groups in animal societies, or kin groups (or families) within social groups. Individuals within such clusters are more likely to interact with each other than individuals from different clusters.\nThere are many algorithms to detect clusters in social networks, and one might work better than another under some circumstances (see, e.g., Emmons et al. 2016). Therefore, the aim of this and the next post is to simulate clustered social networks, and then to apply and compare some of the methods provided by the R-package igraph with these networks.\nNote that there are functions available for R to create such networks, but here I create these networks ‘from scratch’ for two reasons:\nIt is easier to understand (and modify) the process underlying the network simulation. Some clusters might be ‘closer’ to each other than other clusters. For example, individuals from two close families might be more likely to interact with each other than with individuals from other families. Perhaps, this can be achieved with the available functions, but I preferred to model these different degrees of clustering on my own.  This project will consist of two parts:\n1. Simulate clustered social networks. I will simulate values of an ‘association index’ (reflecting social relationships) for dyads of individuals within the same groups, for dyads of individuals from ‘close’ groups, and for dyads consisting of individuals from different groups that are not close to each other. In total, I will simulate four different scenarios with varying degrees of clustering.\n2. Determine clustering using different methods and compare the results. I will use several of the methods provided by the igraph package to detect clusters in these simulated networks. Then, I will calculate and compare the modularity of different networks, the number of detected clusters in comparison to simulated clusters, and the proportion of dyads correctly assigned to the same cluster.\n1. Simulate clustered social networks 1.1 Prepare R rm(list = ls()) library(tidyverse) library(tidygraph) library(ggraph) library(igraph)  1.2 Create a dataframe with identities and group memberships of individuals # Specify number of individuals and groups (or clusters) n_inds \u0026lt;- 50 n_groups \u0026lt;- 4 # Create IDs for all individuals and assign random social groups to individuals set.seed(1209) individual_df \u0026lt;- tibble( Ind = paste0(\u0026quot;ind_\u0026quot;, str_pad(1:n_inds, width = nchar(n_inds), pad = \u0026quot;0\u0026quot;)), Group = sample(x = paste0(\u0026quot;group_\u0026quot;, letters[1:n_groups]), size = n_inds, replace = T)) # Create a dataframe with all possible combinations of individuals except \u0026#39;self-relationships\u0026#39; network_df \u0026lt;- expand.grid(Ind_A = individual_df$Ind, Ind_B = individual_df$Ind, stringsAsFactors = F) %\u0026gt;% left_join(select(individual_df, Ind_A = Ind, Ind_A_Group = Group), by = \u0026quot;Ind_A\u0026quot;) %\u0026gt;% left_join(select(individual_df, Ind_B = Ind, Ind_B_Group = Group), by = \u0026quot;Ind_B\u0026quot;) %\u0026gt;% filter(Ind_A != Ind_B) # Limit the dataframe to one row per dyad for an undirected network network_df \u0026lt;- network_df %\u0026gt;% arrange(Ind_A, Ind_B) %\u0026gt;% mutate(dyad = if_else(Ind_A \u0026lt; Ind_B, paste0(Ind_A, \u0026quot;_\u0026quot;, Ind_B), paste0(Ind_B, \u0026quot;_\u0026quot;, Ind_A))) %\u0026gt;% distinct(dyad, .keep_all = T) head(network_df) ## Ind_A Ind_B Ind_A_Group Ind_B_Group dyad ## 1 ind_01 ind_02 group_b group_a ind_01_ind_02 ## 2 ind_01 ind_03 group_b group_c ind_01_ind_03 ## 3 ind_01 ind_04 group_b group_b ind_01_ind_04 ## 4 ind_01 ind_05 group_b group_d ind_01_ind_05 ## 5 ind_01 ind_06 group_b group_a ind_01_ind_06 ## 6 ind_01 ind_07 group_b group_b ind_01_ind_07  1.3 Assign values (or ‘weights’) to all dyadic relationships. Here, I use 4 different scenarios:\n1. Scenario (S1): Within-group relationships (wgr) are relatively strong in comparison to between-group relationships (bgr). Relationships of individuals between ‘close groups’ (bcgr) are intermediate.\n2. Scenario (S2): Similar to S1, but differences between wgr, bcgr, and bgr are smaller.\n3. Scenario (S3): Wgr are relatively strong in comparison to bgr. This scenario is identical to S1 except that there are no close groups.\n4. Scenario (S4): Differences between wgr and bgr are smaller than in S3. This scenario is identical to S2 except that there are no close groups.\nThus, bgr are the same in all four scenarios, only bcgr and wgr are varied. Furthermore, wgr are the same for S1 and S3, and for S2 and S4 (see plot below).\nTo create the social networks, I sample values from beta distributions simulating an Association Index. Such an index is commonly used in animal behavioural research to assess relationships between individuals (see, e.g., the great book by Whitehead, 2008), and they range from 0 to 1. For example, individuals that never associate with each other would have an association index of 0, and two individuals that are always associated with each other have an index of 1.\n# Set the parameters (i.e. shape parameters of the beta distribution) for all 4 # scenarios bgr \u0026lt;- c(1, 8) bcgr_1 \u0026lt;- c(3, 8) wgr_1 \u0026lt;- wgr_3 \u0026lt;- c(8, 8) bcgr_2 \u0026lt;- c(1.5, 8) wgr_2 \u0026lt;- wgr_4 \u0026lt;- c(4, 8) # Define function for plotting of beta distributions plot_beta \u0026lt;- function(x, alpha_beta, main = \u0026quot;\u0026quot;, xlab = \u0026quot;\u0026quot;, ylab = \u0026quot;\u0026quot;, ...){ alpha = alpha_beta[1] beta = alpha_beta[2] plot(x, dbeta(x, alpha, beta), type = \u0026quot;l\u0026quot;, yaxt = \u0026quot;n\u0026quot;, xlab = \u0026quot;\u0026quot;, ylab = \u0026quot;\u0026quot;, bty = \u0026quot;n\u0026quot;, ...) title(ylab = ylab, line = 0) title(xlab = xlab, line = 2) title(main = main, line = 1) axis(side = 2, label = F, lwd.ticks = F) } # Plot the distributions of social relationships according to these parameters { par(mfrow = c(4,3), mar = c(3, 2, 2, 1)) x \u0026lt;- seq(0, 1, length.out = 40) # S1 plot_beta(x, bgr, main = \u0026quot;Between-group - S1\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;) plot_beta(x, bcgr_1, main = \u0026quot;Between close-groups - S1\u0026quot;) plot_beta(x, wgr_1, main = \u0026quot;Within-group S1\u0026quot;) # S2 plot_beta(x, bgr, main = \u0026quot;Between-group - S2\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;) plot_beta(x, bcgr_2, main = \u0026quot;Between close-groups - S2\u0026quot;, xlab = \u0026quot;Association Index\u0026quot;) plot_beta(x, wgr_2, main = \u0026quot;Within-group - S2\u0026quot;) # S3 plot_beta(x, bgr, main = \u0026quot;Between-group - S3\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;) plot.new() plot_beta(x, wgr_3, main = \u0026quot;Within-group - S3\u0026quot;) # S4 plot_beta(x, bgr, main = \u0026quot;Between-group - S4\u0026quot;, ylab = \u0026quot;Prob. density function\u0026quot;, xlab = \u0026quot;Association Index\u0026quot;) plot.new() plot_beta(x, wgr_4, main = \u0026quot;Within-group - S4\u0026quot;, xlab = \u0026quot;Association Index\u0026quot;) } These distributions can be used to get values for the strength of relationships. To do so, I first define a function to sample dyadic values from the different distributions depending on group membership of both individuals. Then, I use this function to get values for all dyads and for all scenarios. For S1 and S2, group A and B are defined as the close groups.\nget_weights \u0026lt;- function(network_df, wgr, bgr, bcgr = NA, close_groups = NA){ # Create empty vector for all weights weights = rep(NA_real_, time = nrow(network_df)) # Go through all dyads and sample from respective distribution, dependent on # the group membership of both individuals for(i in seq_along(weights)){ ind_A_group \u0026lt;- network_df[i, \u0026quot;Ind_A_Group\u0026quot;] ind_B_group \u0026lt;- network_df[i, \u0026quot;Ind_B_Group\u0026quot;] # Both individuals in same group if(ind_A_group == ind_B_group){ weights[i] \u0026lt;- rbeta(n = 1, shape1 = wgr[1], shape2 = wgr[2]) } # Individuals in different groups if(ind_A_group != ind_B_group){ weights[i] \u0026lt;- rbeta(n = 1, shape1 = bgr[1], shape2 = bgr[2]) } # If some groups are \u0026#39;closer\u0026#39; to each other, use specified distributions for # this kind of relationships if(all(!is.na(bcgr)) \u0026amp; all(!is.na(close_groups)) \u0026amp; ind_A_group != ind_B_group \u0026amp; ind_A_group %in% close_groups \u0026amp; ind_B_group %in% close_groups){ weights[i] \u0026lt;- rbeta(n = 1, shape1 = bcgr[1], shape2 = bcgr[2]) } } return(weights) } set.seed(1209) network_df$S1 \u0026lt;- get_weights(network_df, wgr = wgr_1, bgr = bgr, bcgr = bcgr_1, close_groups = c(\u0026quot;group_a\u0026quot;, \u0026quot;group_b\u0026quot;)) network_df$S2 \u0026lt;- get_weights(network_df, wgr = wgr_2, bgr = bgr, bcgr = bcgr_2, close_groups = c(\u0026quot;group_a\u0026quot;, \u0026quot;group_b\u0026quot;)) network_df$S3 \u0026lt;- get_weights(network_df, wgr = wgr_3, bgr = bgr) network_df$S4 \u0026lt;- get_weights(network_df, wgr = wgr_4, bgr = bgr) As the last step for part 1 of this post, I will illustrate the created networks using the ggraph package (look here for an introduction to this package by the author)\nset.seed(1209) clustered_network_plot \u0026lt;- network_df %\u0026gt;% pivot_longer(cols = matches(\u0026quot;S\\\\d\u0026quot;), names_to = \u0026quot;Scenario\u0026quot;, values_to = \u0026quot;weight\u0026quot;) %\u0026gt;% select(from = Ind_A, to = Ind_B, weight, Scenario) %\u0026gt;% filter(weight \u0026gt;= 0.3) %\u0026gt;% as_tbl_graph() %\u0026gt;% activate(nodes) %\u0026gt;% left_join(distinct(individual_df, name = Ind, group = Group), by = \u0026quot;name\u0026quot;) %\u0026gt;% ggraph(., layout = \u0026quot;fr\u0026quot;) + geom_edge_arc(aes(width = weight), alpha = 0.4, strength = 0.1) + scale_edge_width(name = \u0026quot;Association Index\u0026quot;, range = c(0.2, 1)) + geom_node_point(aes(fill = group, shape = group), size = 2) + scale_fill_brewer(type = \u0026quot;qual\u0026quot;, palette = 2) + scale_shape_manual(values = c(21, 22, 23, 24)) + facet_edges(~Scenario) + theme_graph() clustered_network_plot As modeled above, S1 and S3 are very similar, except that group A and B are closer to each other in S1. S2 and S4 have both weaker within-group relationships compared to their counterparts S1 and S3, respectively. Thus, I have four different networks with different degrees of clustering, and in two of these networks, two of the four groups are closer to each other than to the other groups.\nIn the next post, I will use different algorithms from the igraph package to check how well these clusters can be detected.\n  ","date":1577750400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578053796,"objectID":"b0f93e98d4f3cce78629c6e9e83567f3","permalink":"/content/post/social-clusters-i/","publishdate":"2019-12-31T00:00:00Z","relpermalink":"/content/post/social-clusters-i/","section":"post","summary":"Social networks often exhibit some kind of clustering (or community structure), such as distinct social groups in animal societies, or kin groups (or families) within social groups. Individuals within such clusters are more likely to interact with each other than individuals from different clusters.\nThere are many algorithms to detect clusters in social networks, and one might work better than another under some circumstances (see, e.g., Emmons et al. 2016).","tags":["R","Social Networks","ggraph","igraph"],"title":"Creation and Detection of Clusters in Social Networks - Part 1","type":"post"}]